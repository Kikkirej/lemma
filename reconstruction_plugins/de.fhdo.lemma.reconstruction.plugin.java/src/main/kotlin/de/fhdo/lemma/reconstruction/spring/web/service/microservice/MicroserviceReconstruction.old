package de.fhdo.lemma.reconstruction.spring.service.microservice

import com.github.javaparser.JavaParser
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.getPackageName
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.hasAnnotation
import de.fhdo.lemma.reconstruction.spring.parser.JavaParseTree
import de.fhdo.reconstruction.framework.modules.AbstractReconstructionModule
import de.fhdo.reconstruction.framework.modules.service.microservice.Microservice
import de.fhdo.reconstruction.framework.modules.service.microservice.MicroserviceReconstructionModule
import de.fhdo.reconstruction.framework.modules.service.microservice.createMicroservice
import de.fhdo.reconstruction.framework.plugins.AbstractParseTree
import de.fhdo.reconstruction.framework.plugins.ParsingResultType
import de.fhdo.reconstruction.framework.plugins.ParsingResultType.*
import java.io.File

@MicroserviceReconstructionModule
class MicroserviceReconstruction : AbstractReconstructionModule() {
    override fun <T : Any> execute(abstractParseTree: AbstractParseTree): List<T> {
        val microservices = mutableListOf<Microservice>()
        val parseTree = abstractParseTree as JavaParseTree
        val clazz = parseTree.compilationUnit.findFirst(ClassOrInterfaceDeclaration::class.java)
        { !it.isInterface }.orElse(null)

        if (clazz != null && clazz.hasAnnotation("SpringBootApplication"))
            microservices.add(createMicroservice("${clazz.getPackageName()}.${clazz.nameAsString}",
                "v01", "functional", "public"))
        return microservices as List<T>
    }

    override fun getParsingTree(path: String): Pair<ParsingResultType, AbstractParseTree> {
        val unit = JavaParser().parse(File(path)).result.get()
        val javaParseTree = JavaParseTree("java", unit)
        return FULLY_PARSED to javaParseTree
    }

    override fun getSupportFileExtensions() = listOf("java")
}