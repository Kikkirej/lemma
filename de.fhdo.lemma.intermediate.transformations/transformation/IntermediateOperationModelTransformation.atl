-- @path Operation=/de.fhdo.lemma.operationdsl.metamodel/model/OperationViewpointModel.xcore
-- @path Intermediate=/de.fhdo.lemma.operationdsl.intermediate.metamodel/model/IntermediateOperationModel.xcore

-- Author: Philip Wizenty
-- E-mail: philip.wizenty@fh-dortmund.de

module IntermediateOperationModelTransformation;
create OUT : Intermediate from IN : Operation;

--- Rule to generate the root of the target intermediate Operation model
rule IntermediateOperationModel {
    from
        operationModel : Operation!OperationModel
    to
        intermediateOperationModel : Intermediate!IntermediateOperationModel(
            sourceModelUri <- Operation!OperationModel.allInstances().first().t_modelUri
        )
    do {
        -- Add imports to operation model
        for (import in operationModel.imports) {
            intermediateOperationModel.imports <- thisModule.IntermediateImport(import);
        }


        -- Add containers to operation model
        for (container in operationModel.containers) {
            intermediateOperationModel.containers <- thisModule.IntermediateContainer(
                container,
                intermediateOperationModel
            );
        }

        -- Note: The infrastructure nodes are added to the operation model in three seperate steps.
        -- The Division in three steps is necessary to increase the usability and to assign
        -- refernces between different infrastructure nodes.
        -- The frist the creates the acutal intermediate infrastrucre nodes including all basic
        -- attributes e.g. names or import types.
        for (infrastructureNode in operationModel.infrastructureNodes) {
            intermediateOperationModel.infrastructureNodes <-
                thisModule.IntermediateInfrastructureNodeAttributes(
                    infrastructureNode,
                    intermediateOperationModel
            );
        }
        -- The second steps assign all references to other existing concepts.
        for (infrastructureNode in operationModel.infrastructureNodes) {
            thisModule.IntermediateInfrastructureNodeReferences(infrastructureNode);
        }

        -- The third steps assign all depedencies to other operation nodes.
        for (infrastructureNode in operationModel.infrastructureNodes) {
            thisModule.IntermediateInfrastructureNodeDependencies(infrastructureNode);
        }
        intermediateOperationModel;
    }
}

--- Transform a source Import to a target IntermediateImport
rule IntermediateImport (import : Operation!Import) {
    to
        intermediateImport : Intermediate!IntermediateImport(
            name <- import.name,
            importUri <- import.importURI,
            -- Note that normally this would be a direct mapping between the source and the target
            -- importType. However, the XMI serlializer seems to be bugged. See the comments in the
            -- metamodel on why here the name of the import type is used instead.
            importTypeName <- thisModule.getImportTypeName(import)
        )
    do {
        intermediateImport;
    }
}

--- Helper to get the name of an import type without preceding hash sign ('#')
helper def : getImportTypeName(import : Operation!Import) : String =
    let
        rawImportTypeName : String = import.importType.toString()
    in
    if (rawImportTypeName.startsWith('#')) then
        rawImportTypeName.substring(2, rawImportTypeName.size())
    else
        rawImportTypeName
    endif
;

--- Transform a source Container, to an IntermediateContainer
rule IntermediateContainer(container : Operation!Container,
    model : Intermediate!IntermediateOperationModel) {
    to
        intermediateContainer : Intermediate!IntermediateContainer(
            name <- container.name,
            technologyReference <- thisModule.IntermediateDeploymentTechnologyReference(
                container.deploymentTechnology,
                container.operationEnvironment
            ),
            operationModel <- model
        )
    do {
       thisModule.IntermediateContainerReferencesAssignment(intermediateContainer, container);
       intermediateContainer;
    }
}
--- Assign references to an existing intermediate container
rule IntermediateContainerReferencesAssignment(container : Intermediate!IntermediateContainer,
    sourceContainer : Operation!Container) {
    do {
        -- Assign a OperationEnvironment to the container
        if (not container.technologyReference.technology.environment.oclIsUndefined()) {
              container.operationEnvironment
                  <- container.technologyReference.technology.environment;
        }

        -- Assign technology imports to the container
        for (import in sourceContainer.technologies) {
            container.imports <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = import.name and i.importUri = import.importURI);
        }

        -- Assign the DeployedServices of the contaier
        for (deployedService in sourceContainer.deployedServices) {
           container.deployedServices <- thisModule.OperationMicroserviceReference(deployedService);
        }

        -- Assign a ServiceDeplymentSpecification to the container
        for (deploymentSpecification in sourceContainer.deploymentSpecifications) {
            container.specifications <- thisModule.IntermediateServiceDeploymentSpecification(
                container,
                deploymentSpecification
            );
        }

        -- Assign DefaultBasicEndpoints to the container
        for (defaultBasicEndpoint in sourceContainer.defaultBasicEndpoints) {
            for (protocol in defaultBasicEndpoint.protocols) {
                container.endpoints <- thisModule.IntermediateOperationEndpoint(
                    defaultBasicEndpoint,
                    protocol
                );
            }
        }

        -- Assign the DefaultServicePropertyValues to the Container
        for (defaultValue in sourceContainer.defaultServicePropertyValues) {
            container.defaultValues <- thisModule.IntermediateTechnologySpecificPropertyValue(
                OclUndefined,
                defaultValue
            );
        }

        -- Assign the operational Aspect to the container
        for (aspect in sourceContainer.aspects) {
            container.aspects <- thisModule.IntermediateImportedAspect(container, aspect);
        }

        -- Assign container and infrastructure nodes on which the InfrastructureNode depends on
        for (possiblyImportedNode in sourceContainer.dependsOnNodes) {
            if (possiblyImportedNode.node.oclIsKindOf(Operation!InfrastructureNode)){
                container.dependsOnNodes <-
                    thisModule.IntermediatePossiblyImportedInfrastructureNode(possiblyImportedNode);
            }

            if (possiblyImportedNode.node.oclIsKindOf(Operation!Container)) {
                container.dependsOnNodes <-
                    thisModule.IntermediatePossiblyImportedContainer(possiblyImportedNode);
            }
        }

        -- Assign container and infrastructure nodes which the InfrastrucureNode uses
        for (possiblyImportedNode in sourceContainer.usedByNodes) {
            if (possiblyImportedNode.node.oclIsKindOf(Operation!InfrastructureNode)) {
                container.usedByNodes <-
                    thisModule.IntermediatePossiblyImportedInfrastructureNode(possiblyImportedNode);
            }

            if (possiblyImportedNode.node.oclIsKindOf(Operation!Container)) {
                container.usedByNodes <-
                    thisModule.IntermediatePossiblyImportedContainer(possiblyImportedNode);
            }
        }
    }
}

--- Called rule to create an IntermediateDeploymentTechnologyReference instance
rule IntermediateDeploymentTechnologyReference(
    sourceTechnologyReference : Operation!DeploymentTechnologyReference,
    sourceEnvironment : Operation!OperationEnvironment) {
    to
        reference : Intermediate!IntermediateDeploymentTechnologyReference(
                technology <- thisModule.IntermediateDeploymentTechnology(
                    sourceTechnologyReference.deploymentTechnology,
                    reference
                )
        )
    do {
        -- Link an OperationEnvironment to the DeploymentTechnologyReference if present
        if(not sourceEnvironment.oclIsUndefined()) {
            thisModule.IntermediateOperationEnvironment(sourceEnvironment, reference.technology);
        }

        reference.import <- Intermediate!IntermediateImport.allInstances()
            ->any(i | i.name = sourceTechnologyReference.import.name
                and i.importUri = sourceTechnologyReference.import.importURI);
        reference;
    }
}

--- Called rule to create an IntermediateDeploymentTechnology instance
rule IntermediateDeploymentTechnology(sourceDeploymentTechnology : Operation!DeploymentTechnology,
    targetTechnologyReference : Intermediate!IntermediateDeploymentTechnologyReference) {
    to
        technology : Intermediate!IntermediateDeploymentTechnology(
            name <- sourceDeploymentTechnology.name,
            reference <- targetTechnologyReference
        )
    do {
        -- Assign a TechnologySpecificProperty to a DeploymentTechnology
        for (technologySpecificProperty in sourceDeploymentTechnology.serviceProperties){
            technology.properties.append(
                thisModule.IntermediateTechnologySpecificProperty(
                    technologySpecificProperty,
                    technology
                )
            );
        }
        technology;
    }
}

--- Called rule to create an IntermediateOperationEnvironment instance
rule IntermediateOperationEnvironment(sourceEnvironment : Operation!OperationEnvironment,
    technology : Intermediate!IntermediateDeploymentTechnology) {
    to
        environment : Intermediate!IntermediateOperationEnvironment(
            environmentName <- sourceEnvironment.environmentName,
            operationTechnology <- technology,
            default <- sourceEnvironment.default
        )
}

rule IntermediateInfrastructureNodeAttributes(node : Operation!InfrastructureNode,
    model : Intermediate!IntermediateOperationModel) {
    to
        infrastructureNode : Intermediate!IntermediateInfrastructureNode(
            name <- node.name,
            reference <- thisModule.IntermediateInfrastructureTechnologyReference(
                node.infrastructureTechnology,
                node.operationEnvironment
            )
        )
    do {
        if (not model.oclIsUndefined()) {
            infrastructureNode.operationModel <- model;
        }

        for (technology in node.technologies) {
            infrastructureNode.imports <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = technology.name and i.importUri = technology.importURI);
        }
        infrastructureNode;
    }
}

--- Transform a source InfrastructureNode, to a target IntermediateInfrastructureNode
rule IntermediateInfrastructureNodeReferences(infrastructureNode : Operation!InfrastructureNode) {
    using {
        intermediateInfrastrucutreNode : Intermediate!IntermediateInfrastructureNode
            = Intermediate!IntermediateInfrastructureNode.allInstances()->any(n |
                n.name = infrastructureNode.name);
    }
    do {
        thisModule.IntermediateInfrastructureNodeReferencesAssignment(
            intermediateInfrastrucutreNode, infrastructureNode);
    }
}

rule IntermediateInfrastructureNodeReferencesAssignment(
    intermediateInfrastructureNode : Intermediate!IntermediateInfrastructureNode,
    infrastructureNode : Operation!InfrastructureNode) {
     do {
        -- Assign an OperationEvironment to the InfrastructureNode
        if (not intermediateInfrastructureNode.reference.technology.environment.oclIsUndefined()) {
            intermediateInfrastructureNode.operationEnvironment <-
                intermediateInfrastructureNode.reference.technology.environment;
        }

        -- Assign technology imports to the InfrastructureNode
        for (import in infrastructureNode.technologies) {
            intermediateInfrastructureNode.imports <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = import.name and i.importUri = import.importURI);
        }

        -- Assign Endpoints to the InfrastructureNode, note that each protocol results in a seperate
        --  endpoint
        for (infrastructureEndpoint in infrastructureNode.endpoints) {
            for (protocol in infrastructureEndpoint.protocols) {
                intermediateInfrastructureNode.endpoints <-
                    thisModule.IntermediateOperationEndpoint(infrastructureEndpoint, protocol);
            }
        }

        -- ServiceDeploymentSpecification is missing for infrastructural nodes. The DSL only allows
        -- a specification for imported Microservices, not for infrastructure nodes.

        -- Assign DefaultServicePropertyValues to the InfrastructureNode
        -- The ServiceDeploymentSpecification is oclUndefined in this use of the called rule
        -- but necessary to reuse it in the ServiceDeploymentSpecificatio called rule
        for (defaultValue in infrastructureNode.defaultServicePropertyValues) {
            intermediateInfrastructureNode.defaultValues <-
                thisModule.IntermediateTechnologySpecificPropertyValue(OclUndefined, defaultValue);
        }

        -- Assign OperationAspects to the InfrastructureNode
        for (aspect in infrastructureNode.aspects) {
            intermediateInfrastructureNode.aspects <-
                thisModule.IntermediateImportedAspect(intermediateInfrastructureNode, aspect);
        }
    }
}
--- Transform a source InfrastructureNode, to a target IntermediateInfrastructureNode
rule IntermediateInfrastructureNodeDependencies(infrastrucutreNode : Operation!InfrastructureNode) {
    using {
        intermediateInfrastrucutreNode : Intermediate!IntermediateInfrastructureNode
            = Intermediate!IntermediateInfrastructureNode.allInstances()->any(n |
                n.name = infrastrucutreNode.name
            );
    }
    do {
         -- Assign nodes on which the InfrastructureNode depens on
        for (node in infrastrucutreNode.dependsOnNodes) {
            if (node.node.oclIsKindOf(Operation!InfrastructureNode)) {
                intermediateInfrastrucutreNode.dependsOnNodes <-
                    thisModule.IntermediatePossiblyImportedInfrastructureNode(node);
            }

            if (node.node.oclIsKindOf(Operation!Container)) {
                intermediateInfrastrucutreNode.dependsOnNodes <-
                    thisModule.IntermediatePossiblyImportedContainer(node);
            }

        }

        -- Assign nodes which the InfrastrucureNode uses
        for (node in infrastrucutreNode.usedByNodes) {
            if (node.node.oclIsKindOf(Operation!InfrastructureNode)) {
                intermediateInfrastrucutreNode.usedByNodes <-
                    thisModule.IntermediatePossiblyImportedInfrastructureNode(node);
            }

            if (node.node.oclIsKindOf(Operation!Container)) {
                intermediateInfrastrucutreNode.usedByNodes <-
                    thisModule.IntermediatePossiblyImportedContainer(node);
            }
        }

        -- Assign services which which are used by the infrastructure node
        for (deployedService in infrastrucutreNode.deployedServices) {
            intermediateInfrastrucutreNode.deployedServices <-
                thisModule.OperationMicroserviceReference(deployedService);
        }
    }
}

--- Called rule to create a IntermediateInfrastructureTechnologyReference instance
rule IntermediateInfrastructureTechnologyReference(sourceTechnologyReference :
   Operation!InfrastructureTechnologyReference, sourceEnvironment : Operation!OperationEnvironment){
    to
        reference: Intermediate!IntermediateInfrastructureTechnologyReference(
            technology <- thisModule.IntermediateInfrastructureTechnology(
                sourceTechnologyReference.infrastructureTechnology,
                reference
            )
        )
    do {
        if(not sourceEnvironment.oclIsUndefined()) {
            thisModule.IntermediateOperationEnvironment(sourceEnvironment, reference.technology);
        }
        reference.import <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = sourceTechnologyReference.import.name
                and i.importUri = sourceTechnologyReference.import.importURI);
        reference;
    }
}

--- Called rule to create a IntermediateDeploymentTechnology instance
rule IntermediateInfrastructureTechnology(sourceTechnology : Operation!InfrastructureTechnology,
    targetReference : Intermediate!IntermediateInfrastructureTechnologyReference) {
    to
        technology: Intermediate!IntermediateInfrastructureTechnology(
            name <- sourceTechnology.name,
            reference <- targetReference
        )
    do {
        for (technologySpecificProperty in sourceTechnology.serviceProperties){
            technology.properties.append(thisModule.IntermediateTechnologySpecificProperty(
                technologySpecificProperty,
                technology
                )
            );
        }
        technology;
    }
}

--- Called rule to creade a IntermediateTechnologySpecificProperty instance
rule IntermediateTechnologySpecificProperty(sourceTechnologySpecificProperty :
    Operation!TechnologySpecificProperty,
    deploymentTechnology : Intermediate!IntermediateDeploymentTechnology) {
    to
        property : Intermediate!IntermediateTechnologySpecificProperty(
            name <- sourceTechnologySpecificProperty.name,
            type <- sourceTechnologySpecificProperty.type.typeName,
            operationTechnology <- deploymentTechnology
        )

    do {
        -- Assign a DefaultValue to a TechnologySpecificProperty if available
        if (not sourceTechnologySpecificProperty.defaultValue.oclIsUndefined()){
            property.defaultValue <- sourceTechnologySpecificProperty.defaultValue.valueAsString();
        }

        -- Assign a Feature to a TechnologySpecificProperty
        for (feature in sourceTechnologySpecificProperty.features){
            property.featureNames <- feature.toString();
        }
        property;
    }
}

--- Called rule to create a IntermediateTechnologySpecificPropertyValue instance
rule IntermediateTechnologySpecificPropertyValue (deploymentSpecification :
    Intermediate!IntermediateServiceDeploymentSpecification,
    servicePropertyValue : Operation!TechnologySpecificPropertyValueAssignment) {
    to
        value : Intermediate!IntermediateTechnologySpecificPropertyValue(
            value <- servicePropertyValue.value.valueAsString(),
            technologySpecificProperty <- Intermediate!IntermediateTechnologySpecificProperty
                .allInstances()->any(p | p.name = servicePropertyValue.property.name)
        )
    do {
        value;
    }
}

--- Called rule to create a IntermediateServiceDeploymentSpecification instance
rule IntermediateServiceDeploymentSpecification(
    targetContainer : Intermediate!IntermediateContainer,
    sourceDeploymentSpecification :Operation!ServiceDeploymentSpecification) {
        to
            property : Intermediate!IntermediateServiceDeploymentSpecification(
                operationNode <- targetContainer,
                operationMicroserviceReference <- Intermediate!OperationMicroserviceReference
                .allInstances()->any(p |
                    (p.name = sourceDeploymentSpecification.service.microservice.name
                        and p.name = sourceDeploymentSpecification.service.microservice.name))
            )
        do{
            -- Assign a TechnologySpecificPropertyValue to a DeploymentSpecification
            for (servicePropertyValue in sourceDeploymentSpecification.servicePropertyValues) {
                property.propertyValues <-
                    thisModule.IntermediateTechnologySpecificPropertyValue(
                        property,
                        servicePropertyValue
                    );
            }

            -- Assign a BasicEndpoint to a DeploymentSpecification
            for (basicEndpoint in sourceDeploymentSpecification.basicEndpoints) {
                for (protocol in basicEndpoint.protocols) {
                    property.endpoints <- thisModule.IntermediateOperationEndpoint(
                        basicEndpoint,
                        protocol
                    );
                }
            }
            property;
        }
}

--- Called rule to create a IntermediateServiceDeploymentSpecification instance
rule OperationMicroserviceReference(sourceMicroservice : Operation!ImportedMicroservice) {
    to
        reference : Intermediate!OperationMicroserviceReference(
            imported <- true,
            name <- sourceMicroservice.microservice.name,
            microserviceType <- sourceMicroservice.microservice.type.toString(),
            effectivelyImplemented <- sourceMicroservice.microservice.effectivelyImplemented,
            import <- Intermediate!IntermediateImport.allInstances()
                -> any(p | p.name = sourceMicroservice.import.name),
            version <- sourceMicroservice.microservice.version,
            qualifiedName <- sourceMicroservice.microservice.buildQualifiedName('.'),
            visibility <- sourceMicroservice.microservice.effectiveVisibility.name
        )
    do {
        reference.node <- Intermediate!IntermediateOperationNode.allInstances()
            ->any(p | p.name = sourceMicroservice.operationNode.name);
        reference;
    }
}

--- Called rule to create a IntermediateEndPoint instance
rule IntermediateOperationEndpoint(sourceEndpoint : Operation!BasicEndpoint,
    sourceProtocol : Operation!ProtocolAndDataFormat) {
    using {
        technology : Operation!Technology = sourceProtocol.protocol.technology;
        intermediateTechnologyImport : Intermediate!IntermediateImport
            = Intermediate!IntermediateImport.allInstances()->any(i |
                i.name = sourceProtocol.technology.name
        );
    }
    to
        intermediateEndpoint : Intermediate!IntermediateOperationEndpoint(
            addresses <- sourceEndpoint.addresses,
            protocol <- sourceProtocol.protocol.name,
            communicationType <- sourceProtocol.protocol.communicationType.toString()
        )
    do {
        intermediateEndpoint.technology <- thisModule.IntermediateEndpointTechnology(
            intermediateTechnologyImport,
            technology,
            intermediateEndpoint
        );

        if(not sourceProtocol.dataFormat.oclIsUndefined()) {
            intermediateEndpoint.dataFormat <- sourceProtocol.dataFormat;
        }
        if (not sourceProtocol.protocol.defaultFormat.oclIsUndefined()) {
            intermediateEndpoint.dataFormat <- sourceProtocol.protocol.defaultFormat.formatName;
        }
        intermediateEndpoint;
    }
}

--- Create an IntermediateImportedAspect from an ImportedServiceAspect instance
rule IntermediateImportedAspect (operationNode : Intermediate!IntermediateOperationNode,
sourceAspect : Operation!ImportedOperationAspect) {
    to
        aspect : Intermediate!IntermediateImportedAspect(
            name <- sourceAspect.aspect.name,
            import <- Intermediate!IntermediateImport.allInstances()
                -> any(p | p.name = sourceAspect.technology.name)
        )
    do {
        -- Aspect features
        for (feature in sourceAspect.aspect.features) {
            aspect.featureNames <- aspect.featureNames.append(feature.toString());
        }

        -- Create properties of aspect and link them with the aspect
        for (property in sourceAspect.aspect.properties) {
            aspect.properties <- aspect.properties->append(
                thisModule.IntermediateAspectProperty(property, aspect)
            );
        }

        -- Create values of aspect and link them with the aspect. Therefore, we consider both, the
        -- syntactically shorter initialization of a single property aspect and the "normal" case of
        -- "named" property initialization. Independent of how the aspect and its values were
        -- specified, we map an aspect value to a an IntermediateAspectPropertyValue instance.
        if (not sourceAspect.singlePropertyValue.oclIsUndefined())
            thisModule.IntermediateAspectPropertyValue(sourceAspect.singlePropertyValue, aspect,
                aspect.properties->first());
        else
            for (value in sourceAspect.values) {
                thisModule.IntermediateAspectPropertyValue(
                    value.value,
                    aspect,
                    aspect.properties->any(p | p.name = value.property.name)
                );
        }
        aspect;
    }
}

--- Called rule to create an IntermediateAspectProperty instance
rule IntermediateAspectProperty(sourceProperty : Service!TechnologySpecificProperty,
    aspect : Intermediate!IntermediateImportedAspect) {
    to
        property : Intermediate!IntermediateAspectProperty(
            name <- sourceProperty.name,
            type <- sourceProperty.type.typeName,
            aspect <- aspect
        )
    do {
        for (feature in sourceProperty.features) {
            property.featureNames <- property.featureNames.append(feature.toString());
        }

        if (not sourceProperty.defaultValue.oclIsUndefined())
            property.defaultValue <- sourceProperty.defaultValue.valueAsString();

        aspect.properties <- aspect.properties->append(property);
        property;
    }
}

--- Called rule to create an IntermediateAspectPropertyValue instance
rule IntermediateAspectPropertyValue(sourceValue : Service!PrimitiveValue,
    aspect : Intermediate!IntermediateImportedAspect,
    property : Intermediate!IntermediateAspectProperty) {
    to
        value : Intermediate!IntermediateAspectPropertyValue(
            value <- sourceValue.valueAsString(),
            aspect <- aspect,
            property <- property
        )
    do {
        aspect.propertyValues->append(value);
        value;
    }
}

--- Called rule to generate IntermediateTechnology instances
rule IntermediateEndpointTechnology(
    intermediateImport : Intermediate!IntermediateImport,
    sourceTechnology : Operation!Technology,
    operationEndpoint : Intermediate!IntermediateOperationEndpoint) {
    to
        technology : Intermediate!IntermediateEndpointTechnology(
            name <- sourceTechnology.name,
            import <- intermediateImport,
            endpoint <- operationEndpoint
        )
    do {
        technology;
    }
}

--- Called rule to generate a PossiblyImportedOperationNode instances
rule IntermediatePossiblyImportedInfrastructureNode(possiblyOperationNode :
    Operation!PossiblyImportedOperationNode) {
    to
        infrastructureNode : Intermediate!IntermediateInfrastructureNode(
            name <- possiblyOperationNode.node.name,
            reference <- thisModule.IntermediateInfrastructureTechnologyReference(
                possiblyOperationNode.node.infrastructureTechnology,
                possiblyOperationNode.node.operationEnvironment)
        )
    do {
        if (not possiblyOperationNode.import.oclIsUndefined()) {
            infrastructureNode.imported <- true;
            infrastructureNode.imports <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = possiblyOperationNode.import.name);
        }
        thisModule.IntermediateInfrastructureNodeReferencesAssignment(
            infrastructureNode,
            possiblyOperationNode.node
        );
        infrastructureNode;
    }
}

--- Called rule to generate a PossiblyImportedOperationNode instances
rule IntermediatePossiblyImportedContainer(possiblyContainer :
    Operation!PossiblyImportedOperationNode ) {
    to
        container : Intermediate!IntermediateContainer(
            name <- possiblyContainer.node.name,
            technologyReference <- thisModule.IntermediateDeploymentTechnologyReference(
                possiblyContainer.node.deploymentTechnology,
                possiblyContainer.node.operationEnvironment)
        )
    do {
        if (not possiblyContainer.import.oclIsUndefined()) {
            container.imported <- true;
            container.imports <- Intermediate!IntermediateImport.allInstances()
                ->any(i | i.name = possiblyContainer.import.name);
        }
        thisModule.IntermediateContainerReferencesAssignment(container, possiblyContainer.node);
        container;
    }
}