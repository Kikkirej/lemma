/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.data.validation

import org.eclipse.xtext.validation.Check
import de.fhdo.lemma.data.ComplexTypeImport
import org.eclipse.xtext.EcoreUtil2
import de.fhdo.lemma.data.DataModel
import de.fhdo.lemma.data.DataPackage
import de.fhdo.lemma.data.DataStructure
import de.fhdo.lemma.data.DataField
import org.eclipse.xtext.naming.QualifiedName
import de.fhdo.lemma.data.Version
import com.google.common.base.Function
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import de.fhdo.lemma.utils.LemmaUtils
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import de.fhdo.lemma.data.Context
import de.fhdo.lemma.data.DataOperation

/**
 * This class contains validation rules for the Data DSL.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class DataDslValidator extends AbstractDataDslValidator {
    /* For debugging purposes to test the type checker. May be safely removed in the future. */
    /*@Check
    def checkAssignTest(AssignTest assignTest) {
        try {
            new TypeChecker().checkTypeCompatibility(assignTest.target.complexType,
                assignTest.source.complexType)
        } catch (TypesNotCompatibleException ex) {
            warning(ex.message, assignTest, DataPackage::Literals.ASSIGN_TEST__SOURCE)
        }
    }*/

    /**
     * Check import aliases for uniqueness. Normally, this should be done by
     * DataDslNamesAreUniqueValidationHelper, but it does not react to
     */
    @Check
    def checkImportAlias(DataModel dataModel) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(dataModel.complexTypeImports, [name])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = dataModel.complexTypeImports.get(duplicateIndex)
        error('''Duplicate import alias «duplicate.name»''', duplicate,
            DataPackage::Literals.COMPLEX_TYPE_IMPORT__NAME)
    }

    /**
     * Check that imported file is imported exactly once
     */
    @Check
    def checkImportFileUniqueness(DataModel dataModel) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(dataModel.complexTypeImports, [importURI])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = dataModel.complexTypeImports.get(duplicateIndex)
        error("File is already being imported", duplicate,
            DataPackage::Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI)
    }

    /**
     * Check that imported file defines a data model
     */
    @Check
    def checkImportType(ComplexTypeImport complexTypeImport) {
        if (!LemmaUtils.isImportOfType(complexTypeImport.eResource, complexTypeImport.importURI,
            DataModel))
            error("File does not contain a data model definition", complexTypeImport,
                DataPackage::Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI)
    }

    /**
     * Check versions for unique names
     */
    @Check
    def checkUniqueVersionNames(DataModel dataModel) {
        checkUniqueNames(dataModel.versions, "version", [name], [name],
            DataPackage::Literals.VERSION__NAME)
    }

    /**
     * Check top-level contexts for unique names
     */
    @Check
    def checkUniqueContextNames(DataModel dataModel) {
        checkUniqueNames(dataModel.contexts, "context", [name], [name],
            DataPackage::Literals.CONTEXT__NAME)
    }

    /**
     * Check top-level complex types for unique names
     */
    @Check
    def checkUniqueTypeNames(DataModel dataModel) {
        checkUniqueNames(dataModel.complexTypes, "complex type", [name], [name],
            DataPackage::Literals.COMPLEX_TYPE__NAME)
    }

    /**
     * Check contexts defined in versions for unique names
     */
    @Check
    def checkUniqueContextNames(Version version) {
        checkUniqueNames(version.contexts, "context", [name], [name],
            DataPackage::Literals.CONTEXT__NAME)
    }

    /**
     * Check complex types defined in versions for unique names
     */
    @Check
    def checkUniqueTypeNames(Version version) {
        checkUniqueNames(version.complexTypes, "complex type", [name], [name],
            DataPackage::Literals.COMPLEX_TYPE__NAME)
    }

    /**
     * Check complex types defined in contexts for unique names
     */
    @Check
    def checkUniqueTypeNames(Context context) {
        checkUniqueNames(context.complexTypes, "complex type", [name], [name],
            DataPackage::Literals.COMPLEX_TYPE__NAME)
    }

    /**
     * Check operation parameters for unique names
     */
    @Check
    def checkUniqueParameterNames(DataOperation operation) {
        checkUniqueNames(operation.parameters, "parameter", [name], [name],
            DataPackage::Literals.DATA_OPERATION_PARAMETER__NAME)
    }

    /**
     * Generic helper to check a list of EObjects for unique names
     */
    private def <T extends EObject> checkUniqueNames(
        List<T> objectsToCheck,
        String objectKind,
        Function<T, Object> getCompareValue,
        Function<T, String> getDuplicateOutputString,
        EStructuralFeature feature
    ) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(objectsToCheck, getCompareValue)
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = objectsToCheck.get(duplicateIndex)
        error('''Duplicate «objectKind» «getDuplicateOutputString.apply(duplicate)»''', duplicate,
            feature)
    }

    /**
     * Check data structure for unique names
     */
    @Check
    def checkUniqueNames(DataStructure dataStructure) {
        val dataFieldCount = dataStructure.dataFields.size
        val uniqueNames = <String>newArrayList
        uniqueNames.addAll(dataStructure.dataFields.map[it.name])
        uniqueNames.addAll(dataStructure.operations.map[it.name])
        val duplicateIndex = LemmaUtils.getDuplicateIndex(uniqueNames, [it])
        if (duplicateIndex > -1) {
            val isOperation = duplicateIndex >= dataFieldCount
            if (!isOperation)
                error("Duplicate structure component",
                    DataPackage::Literals.DATA_STRUCTURE__DATA_FIELDS, duplicateIndex)
            else {
                val operationIndex = duplicateIndex - dataFieldCount
                error("Duplicate structure component",
                    DataPackage::Literals.DATA_STRUCTURE__OPERATIONS, operationIndex)
            }
        }
    }

    /**
     * Perform checks on data fields
     */
    @Check
    def checkDataField(DataField dataField) {
        /* A data field must either have a type or be hidden */
        if (dataField.effectiveType === null && !dataField.hidden) {
            error('''Field must have a type or be hidden''', dataField,
                    DataPackage::Literals.DATA_FIELD__NAME)

            return
        }

        /* A feature may only be assigned once to a data field */
        val duplicateFeatureIndex = LemmaUtils.getDuplicateIndex(dataField.features, [it])
        if (duplicateFeatureIndex > -1) {
            error("Duplicate feature", dataField,
                DataPackage::Literals.DATA_FIELD__FEATURES, duplicateFeatureIndex)

            return
        }

        /*
         * If there is no equally named super field or the super field is hidden (which means
         * that the complex type does not allow external callers to access it), the field must
         * have a type
         */
        val equalSuperField = dataField.findEponymousSuperField()

        if (equalSuperField === null || equalSuperField.hidden) {
            if (dataField.effectiveType === null)
                error('''Field must have a type''', dataField,
                    DataPackage::Literals.DATA_FIELD__NAME)

        /*
         * A field with a non-hidden super field (that therefore has a type) may not redefine the
         * super field by having a type
         */
        } else if (equalSuperField !== null && !equalSuperField.hidden) {
            var String superQualifiedName = QualifiedName
                .create(equalSuperField.qualifiedNameParts)
                .toString

            if (dataField.effectiveType !== null)
                error('''Field cannot redefine inherited field «superQualifiedName» ''', dataField,
                    DataPackage::Literals.DATA_FIELD__NAME)
            else if (dataField.immutable)
                error("Inherited fields cannot be immutable", dataField,
                    DataPackage::Literals.DATA_FIELD__IMMUTABLE)
        }
    }

    /**
     * Perform checks on data operations
     */
    @Check
    def checkOperation(DataOperation dataOperation) {
        val superOperation = dataOperation.findEponymousSuperOperation()
        val superOperationName = if (superOperation !== null)
                QualifiedName.create(superOperation.qualifiedNameParts).toString
            else
                null
        val superOperationIsHidden = superOperation !== null && superOperation.hidden

        val thisIsInherited = superOperation !== null
        val thisIsHidden = dataOperation.hidden

        val redefinitionAttempt = thisIsInherited && !superOperationIsHidden
        val operationTypesDiffer = thisIsInherited &&
            dataOperation.hasNoReturnType != superOperation.hasNoReturnType

        if (redefinitionAttempt) {
            // In a redefinition attempt, i.e., when the super operation is not hidden, this
            // operation must be hidden
            if (!thisIsHidden) {
                error('''Operation cannot redefine operation «superOperationName» ''',
                        dataOperation, DataPackage::Literals.DATA_OPERATION__NAME)
                return

            // In a redefinition attempt, the operation types of the super and this operation must
            // not differ, i.e., they must be both either procedures or functions
            } else if (operationTypesDiffer) {
                error("Hidden inherited operation must have the same operation type (procedure " +
                    '''or function) as «superOperationName»''', dataOperation,
                    DataPackage::Literals.DATA_OPERATION__NAME)
                return

            // In a redefinition attempt, this operation must be a procedure or function without a
            // return type specification
            } else if (dataOperation.primitiveOrComplexReturnType !== null) {
                error("Hidden inherited operation must not specify a return type", dataOperation,
                    DataPackage::Literals.DATA_OPERATION__NAME)
                return

            // In a redefinition attempt, operations may not specify parameters themselves
            } else if (!dataOperation.parameters.empty) {
                error("Hidden inherited operation must not specify parameters", dataOperation,
                    DataPackage::Literals.DATA_OPERATION__NAME)
                return
            }
        }

        // Operation may only lack a return type specification when it is hidden and inherited
        if (dataOperation.lacksReturnTypeSpecification && (!thisIsHidden || !thisIsInherited))
            error("Operation must have a return type specification or be hidden", dataOperation,
                DataPackage::Literals.DATA_OPERATION__NAME)
    }

    /**
     * Check if an imported file exists
     */
    @Check
    def checkImportFileExists(ComplexTypeImport complexTypeImport) {
        if (!LemmaUtils.importFileExists(complexTypeImport.eResource, complexTypeImport.importURI))
            error("File not found", complexTypeImport,
                DataPackage::Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI)
    }

    /**
     * Check for cyclic inheritance relationships between data structures
     */
    @Check
    def checkCyclicInheritance(DataStructure dataStructure) {
        if (LemmaUtils.hasCyclicInheritance(dataStructure, [it.super]))
            error("Cyclic inheritance detected", dataStructure,
                DataPackage::Literals.COMPLEX_TYPE__NAME)
    }

    /**
     * Check for cyclic imports (non-transitive)
     */
    @Check
    def checkForCyclicImports(ComplexTypeImport complexTypeImport) {
        // Function to retrieve all imported Ecore resources of a data model
        val Function<DataModel, List<Resource>> getImportedDataModelResources =
            [complexTypeImports.map[
                EcoreUtil2.getResource(eResource, importURI)
            ]]

        if (LemmaUtils.isCyclicImport(complexTypeImport, DataModel, getImportedDataModelResources))
            error("Cyclic import detected", complexTypeImport,
                DataPackage::Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI)
    }

    /**
     * Check versions for non-emptyness
     */
    @Check
    def checkVersionNotEmpty(Version version) {
        if (version.contexts.empty && version.complexTypes.empty)
            error("A version must define at least one context or complex type", version,
                DataPackage::Literals.VERSION__NAME)
    }
}
