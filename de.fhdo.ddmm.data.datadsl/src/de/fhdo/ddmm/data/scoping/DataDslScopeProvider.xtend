/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.data.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import de.fhdo.ddmm.data.DataPackage
import de.fhdo.ddmm.data.DataModel
import de.fhdo.ddmm.utils.DdmmUtils
import de.fhdo.ddmm.data.PossiblyImportedComplexType
import org.eclipse.xtext.EcoreUtil2
import de.fhdo.ddmm.data.Version
import de.fhdo.ddmm.data.Context
import java.util.List
import de.fhdo.ddmm.data.DataStructure
import org.eclipse.xtext.scoping.Scopes

/**
 * Scope provider for data models.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class DataDslScopeProvider extends AbstractDataDslScopeProvider {
    /**
     * Build scope for a given context and reference
     */
    override getScope(EObject context, EReference reference) {
        val scope = switch (context) {
            /* Data models */
            DataModel: context.getScope(reference)

            /* Possibly imported complex types */
            PossiblyImportedComplexType: context.getScope(reference)

            /* Data structures */
            DataStructure: context.getScope(reference)
        }

        if (scope !== null)
            return scope
        // Try default scope resolution, if no scope could be determined
        else if (scope === null)
            return super.getScope(context, reference)
    }

    /**
     * Build scope for the given reference in the context of a data model
     */
    private def getScope(DataModel dataModel, EReference reference) {
        switch (reference) {
            case DataPackage::Literals.POSSIBLY_IMPORTED_COMPLEX_TYPE__IMPORT:
                return Scopes::scopeFor(dataModel.complexTypeImports)
            case DataPackage::Literals.POSSIBLY_IMPORTED_COMPLEX_TYPE__COMPLEX_TYPE:
                return dataModel.getScopeForPossiblyImportedComplexTypes(null)
        }
    }

    /**
     * Build scope for the given reference in the context of a possibly imported complex type
     */
    private def getScope(PossiblyImportedComplexType complexType, EReference reference) {
        switch (reference) {
            case DataPackage::Literals.POSSIBLY_IMPORTED_COMPLEX_TYPE__IMPORT: {
                val dataModel = EcoreUtil2.getContainerOfType(complexType, DataModel)
                return Scopes::scopeFor(dataModel.complexTypeImports)
            }
            case DataPackage::Literals.POSSIBLY_IMPORTED_COMPLEX_TYPE__COMPLEX_TYPE:
                return complexType
                    .getScopeForPossiblyImportedComplexTypes(complexType.import?.importURI)
        }
    }

    /**
     * Build scope for the given reference in the context of a data structure
     */
    private def getScope(DataStructure structure, EReference reference) {
        switch (reference) {
            case DataPackage::Literals.DATA_STRUCTURE__SUPER:
                return structure.getScopeForSuperStructures()
        }
    }

    /**
     * Convenience method to create a scope for possibly imported complex types of certain types
     */
    private def getScopeForPossiblyImportedComplexTypes(EObject context, String importUri) {
        /* Determine container and qualified name parts of possibly imported complex type */
        var EObject container
        var List<String> qualifiedNameParts
        val containingVersion = EcoreUtil2.getContainerOfType(context, Version)
        val containingContext = EcoreUtil2.getContainerOfType(context, Context)
        val containingDataModel = EcoreUtil2.getContainerOfType(context, DataModel)

        if (containingVersion !== null) {
            container = containingVersion
            qualifiedNameParts = containingVersion.qualifiedNameParts
        } else if (containingContext !== null) {
            container = containingContext
            qualifiedNameParts = containingContext.qualifiedNameParts
        } else if (containingDataModel !== null) {
            container = containingDataModel
            qualifiedNameParts = null
        }

        /* Build and return scope */
        return DdmmUtils.getScopeForPossiblyImportedConcept(
            container,
            qualifiedNameParts,
            DataModel,
            importUri,
            [containedComplexTypes.toList],
            [it.qualifiedNameParts]
        )
   }

   /**
    * Convenience method to create a scope for super structures
    */
   private def getScopeForSuperStructures(DataStructure structure) {
        // Data structures may only inherit from data structures in the same model
        val modelRoot = EcoreUtil2.getContainerOfType(structure, DataModel)
        val localStructures = modelRoot.containedComplexTypes
            .filter[it instanceof DataStructure && it != structure]
        return DdmmUtils.getScopeWithRelativeQualifiedNames(
            localStructures.toList,
            [qualifiedNameParts],
            structure,
            structure.qualifiedNameParts,
            DataModel
        )
   }
}