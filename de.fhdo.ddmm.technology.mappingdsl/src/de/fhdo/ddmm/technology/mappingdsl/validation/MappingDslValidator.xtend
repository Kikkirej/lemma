/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.mappingdsl.validation

import org.eclipse.xtext.validation.Check
import de.fhdo.ddmm.technology.mapping.MicroserviceMapping
import de.fhdo.ddmm.technology.mapping.MappingPackage
import de.fhdo.ddmm.technology.mapping.TechnologyMapping
import de.fhdo.ddmm.utils.DdmmUtils
import de.fhdo.ddmm.service.ServicePackage
import org.eclipse.xtext.naming.QualifiedName
import de.fhdo.ddmm.technology.CommunicationType
import java.util.List
import org.eclipse.emf.ecore.EObject
import com.google.common.base.Function
import org.eclipse.emf.ecore.EReference
import de.fhdo.ddmm.technology.mapping.InterfaceMapping
import de.fhdo.ddmm.technology.mapping.OperationMapping
import de.fhdo.ddmm.technology.mapping.ReferredOperationMapping
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocolSpecification
import de.fhdo.ddmm.technology.mapping.TechnologySpecificEndpoint
import de.fhdo.ddmm.technology.mapping.PrimitiveParameterMapping
import de.fhdo.ddmm.typechecking.TypeChecker
import de.fhdo.ddmm.typechecking.TypesNotCompatibleException
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType
import de.fhdo.ddmm.data.PrimitiveType
import de.fhdo.ddmm.technology.mapping.ComplexParameterMapping
import de.fhdo.ddmm.data.Type
import de.fhdo.ddmm.technology.mapping.TechnologySpecificFieldMapping
import de.fhdo.ddmm.data.ComplexType
import org.eclipse.emf.ecore.EStructuralFeature
import de.fhdo.ddmm.technology.mapping.TechnologySpecificImportedServiceAspect
import org.eclipse.xtext.EcoreUtil2
import de.fhdo.ddmm.technology.Technology
import de.fhdo.ddmm.technology.mapping.ComplexTypeMapping
import de.fhdo.ddmm.service.Import
import de.fhdo.ddmm.service.Endpoint
import de.fhdo.ddmm.service.ImportType
import de.fhdo.ddmm.service.ServiceModel
import de.fhdo.ddmm.service.Operation
import de.fhdo.ddmm.service.ReferredOperation
import de.fhdo.ddmm.service.TechnologyReference

/**
 * This class contains validation rules for the Mapping DSL.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class MappingDslValidator extends AbstractMappingDslValidator {
    /**
     * Check that model is not empty
     */
    @Check
    def checkModelNotEmpty(TechnologyMapping model) {
        val modelEmpty = model.typeMappings.empty && model.serviceMappings.empty

        if (modelEmpty)
            error("Model must define at least one type or service mapping", model,
                MappingPackage::Literals.TECHNOLOGY_MAPPING__TYPE_MAPPINGS)
    }

    /**
     * Check that imported file is imported exactly once
     */
    @Check
    def checkImportFileUniqueness(TechnologyMapping model) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(model.imports, [importURI])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = model.imports.get(duplicateIndex)
        error("File is already being imported", duplicate,
            ServicePackage::Literals.IMPORT__IMPORT_URI)
    }

    /**
     * Check import aliases for uniqueness
     */
    @Check
    def checkImportAlias(TechnologyMapping model) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(model.imports, [name])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = model.imports.get(duplicateIndex)
        error('''Duplicate import alias «duplicate.name»''', duplicate,
            ServicePackage::Literals.IMPORT__NAME)
    }

    /**
     * Check that technology is assigned only once to a complex type mapping
     */
    @Check
    def checkTechnologyUniqueness(ComplexTypeMapping mapping) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(
            mapping.technologyReferences.map[technology],
            [it]
        )

        if (duplicateIndex > -1)
            error(
                "Duplicate technology assignment",
                MappingPackage::Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES,
                duplicateIndex
            )
    }

    /**
     * Check that technology is assigned only once to a microservice
     */
    @Check
    def checkTechnologyUniqueness(MicroserviceMapping mapping) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(
            mapping.technologyReferences.map[technology],
            [it]
        )

        if (duplicateIndex > -1)
            error(
                "Duplicate technology assignment",
                MappingPackage::Literals.MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES,
                duplicateIndex
            )
    }

    /**
     * Check that only one annotated technology of a microservice mapping contains type definitions
     */
    @Check
    def checkUniqueTypeDefinitionTechnologyForMicroserviceMapping(MicroserviceMapping mapping) {
        checkUniqueTypeDefinitionTechnology(mapping)
    }

    /**
     * Check that only one annotated technology of a complex type mapping contains type definitions
     */
    @Check
    def checkUniqueTypeDefinitionTechnologyForComplexTypeMapping(ComplexTypeMapping mapping) {
        checkUniqueTypeDefinitionTechnology(mapping)
    }

    /**
     * Helper for complex type and microservice mappings to check that only one annotated technology
     * contains type definitions or that one type definition technology is marked as the default one
     */
    def checkUniqueTypeDefinitionTechnology(EObject mapping) {
        var List<TechnologyReference> technologyReferences
        var List<TechnologyReference> typeDefinitionTechnologyReferences
        var EReference technologyReferenceFeature

        switch (mapping) {
            ComplexTypeMapping: {
                technologyReferences = mapping.technologyReferences
                typeDefinitionTechnologyReferences = mapping.allTypeDefinitionTechnologyReferences
                technologyReferenceFeature = MappingPackage::Literals
                    .COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES
            }

            MicroserviceMapping: {
                technologyReferences = mapping.technologyReferences
                typeDefinitionTechnologyReferences = mapping.allTypeDefinitionTechnologyReferences
                technologyReferenceFeature = MappingPackage::Literals
                    .MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES
            }

            default:
                return
        }

        /*
         * Check that only one technology is explicitly marked as containing default type
         * definitions
         */
        val duplicateIndex = DdmmUtils.getDuplicateIndex(
            technologyReferences.map[isTypeDefinitionTechnology],
            [it],
            [it === true]
        )
        if (duplicateIndex > -1) {
            error("Only one technology can be the default type definition technology",
                technologyReferenceFeature, duplicateIndex)
            return
        }

        /*
         * Check that one technology is explicitly marked as containing default definitions, if more
         * than one technology defines types
         */
        // If one technology has been chosen to provide default types, no ambiguity regarding
        // the default types exists
        if (technologyReferences.exists[isIsTypeDefinitionTechnology]) {
            return
        }

        if (typeDefinitionTechnologyReferences.empty ||
            typeDefinitionTechnologyReferences.size == 1) {
            return
        }
        typeDefinitionTechnologyReferences.forEach[
            error("More than one type definition technology detected. One of them needs to " +
                "explicitly be selected as the default type definition technology.", it,
                ServicePackage::Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY)
        ]
    }

    /**
     * Check that annotated technologies of complex type mappings define not only deployment-related
     * concepts
     */
    @Check
    def checkTechnologiesForServiceConcepts(ComplexTypeMapping mapping) {
        checkTechnologiesForServiceConcepts(mapping, mapping.technologyReferences.map[technology],
            MappingPackage::Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES)
    }

    /**
     * Check that annotated technologies of microservice mappings define not only deployment-related
     * concepts
     */
    @Check
    def checkTechnologiesForServiceConcepts(MicroserviceMapping mapping) {
        checkTechnologiesForServiceConcepts(mapping, mapping.technologyReferences.map[technology],
            MappingPackage::Literals.MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES)
    }

    /**
     * Helper to check that annotated technologies define not only deployment-related concepts
     */
    def checkTechnologiesForServiceConcepts(EObject mapping, List<Import> technologies,
        EReference feature) {
        for (i : 0..<technologies.size) {
            val technologyImport = technologies.get(i)
            val technologyModel = DdmmUtils.getImportedModelRoot(technologyImport.eResource,
                technologyImport.importURI, Technology)
            if (technologyModel.primitiveTypes.empty &&
                technologyModel.protocols.empty &&
                technologyModel.serviceAspects.empty) {
                error("Technology does not specify service-related concepts", mapping, feature, i)
            }
        }
    }

    /**
     * Check technologies of a microservice mapping per communication type for unambiguous default
     * protocols
     */
    @Check
    def checkTechnologiesForUniqueDefaultProtocols(MicroserviceMapping mapping) {
        if (mapping.technologyReferences.empty) {
            return
        }

        val nonUniqueCommunicationTypes = CommunicationType.values
            .filter[communicationType |
                !mapping.protocols.exists[communicationType === it.communicationType]
            ]
            .filter[!isDefaultProtocolUnique(mapping, it)]

        for (communicationType : nonUniqueCommunicationTypes) {
            val String typeString = switch (communicationType) {
                case CommunicationType.ASYNCHRONOUS: "asynchronous"
                case CommunicationType.SYNCHRONOUS: "synchronous"
            }
            error('''Ambiguous default protocol for «typeString» communication. The ''' +
                '''mapping needs to explicitly specifiy a protocol for «typeString» ''' +
                '''communication.''', mapping,
                MappingPackage::Literals.MICROSERVICE_MAPPING__MICROSERVICE)
        }
    }

    /**
     * Helper to check if default protocol of a microservice mapping is unique for a given
     * communication type
     */
    private def isDefaultProtocolUnique(MicroserviceMapping mapping,
        CommunicationType communicationType) {
        var boolean alreadyFoundDefaultProtocolForCommunicationType
        for (technologyImport : mapping.technologyReferences.map[technology]) {
            val technologyModel = DdmmUtils.getImportedModelRoot(technologyImport.eResource,
                technologyImport.importURI, Technology)
            val hasDefaultProtocolForCommunicationType = technologyModel.protocols.exists[
                ^default && it.communicationType === communicationType
            ]
            if (hasDefaultProtocolForCommunicationType) {
                if (alreadyFoundDefaultProtocolForCommunicationType)
                    return false
                else
                    alreadyFoundDefaultProtocolForCommunicationType = true
            }
        }

        return true
    }

    /**
     * Check that service mappings are unique
     */
    @Check
    def checkMicroserviceMappingUniqueness(TechnologyMapping model) {
        // Mapping technologies may be empty if the model contains syntax errors
        val modelMappingsWithTechnology = model.serviceMappings
            .filter[!technologyReferences.empty]
            .toList

        checkFirstLevelMappingUniqueness(
            modelMappingsWithTechnology,
            "Service",
            [microservice?.import?.name],
            [microservice.microservice.qualifiedNameParts],
            MappingPackage::Literals.MICROSERVICE_MAPPING__MICROSERVICE
        )
    }

    /**
     * Check that complex type mappings are unique
     */
    @Check
    def checkComplexTypeMappingUniqueness(TechnologyMapping model) {
        // Mapping technologies may be empty if the model contains syntax errors
        val modelMappingsWithTechnology = model.typeMappings
            .filter[!technologyReferences.empty]
            .toList

        checkFirstLevelMappingUniqueness(
            modelMappingsWithTechnology,
            "Type",
            [type?.dataModelImport?.name],
            [type.type.qualifiedNameParts],
            MappingPackage::Literals.COMPLEX_TYPE_MAPPING__TYPE
        )
    }

    /**
     * Helper to check that mappings of elements on the first level of the mapping model like
     * complex types and microservices are unique. This check considers duplicate mappings of
     * elements defined in the same source model, as well as duplicate mappings of elements from
     * different source models.
     */
    private def <T extends EObject> checkFirstLevelMappingUniqueness(
        List<T> mappings,
        String mappingName,
        Function<T, String> getImportName,
        Function<T, List<String>> getQualifiedNameParts,
        EReference mappedElementFeature
    ) {
        // Perform uniqueness check based on import alias and full qualified name of the mapped
        // element in its source model. This check performs the check for a duplicate mapping of a
        // mapped element from the same model.
        val duplicateMappingFound = checkMappingUniqueness(mappings, mappingName,
            [
                val qualifiedNameSegments = <String> newArrayList
                val importName = getImportName.apply(it)
                // The import name may be null in case the model contains errors
                if (importName !== null)
                    qualifiedNameSegments.add(importName)
                qualifiedNameSegments.addAll(getQualifiedNameParts.apply(it))
                QualifiedName.create(qualifiedNameSegments).toString
            ], mappedElementFeature)

        // If no duplicate mapping of the same element has been found, check for duplicate mappings
        // of elements that have the same full qualified name but originate from a different source
        // model. This check is necessary to prevent duplicate names in intermediate service models
        // that result from the intermediate model-to-model transformation.
        if (!duplicateMappingFound)
            checkMappingUniqueness(
                mappings,
                [QualifiedName.create(getQualifiedNameParts.apply(it)).toString],
                mappedElementFeature,
                '''«mappingName» with the same qualified name but from another model has ''' +
                '''already been mapped'''
            )
    }

    /**
     * Check that interface mappings are unique
     */
    @Check
    def checkInterfaceMappingUniqueness(MicroserviceMapping microserviceMapping) {
        checkMappingUniqueness(microserviceMapping.interfaceMappings, "Interface",
            [QualifiedName.create(interface.qualifiedNameParts).toString],
            MappingPackage::Literals.INTERFACE_MAPPING__INTERFACE
        )
    }

    /**
     * Check that operation mappings are unique
     */
    @Check
    def checkOperationMappingUniqueness(MicroserviceMapping microserviceMapping) {
        checkMappingUniqueness(microserviceMapping.operationMappings, "Operation",
            [QualifiedName.create(operation.qualifiedNameParts).toString],
            MappingPackage::Literals.OPERATION_MAPPING__OPERATION
        )
    }

    /**
     * Check that referred operation mappings are unique
     */
    @Check
    def checkReferredOperationMappingUniqueness(MicroserviceMapping microserviceMapping) {
        checkMappingUniqueness(microserviceMapping.referredOperationMappings, "Referred operation",
            [QualifiedName.create(operation.qualifiedNameParts).toString],
            MappingPackage::Literals.REFERRED_OPERATION_MAPPING__OPERATION
        )
    }

    /**
     * Check that communication types and endpoint protocols of technology-specific protocol
     * specifications of a microservice mapping are unique
     */
    @Check
    def checkProtocolSpecificationCommunicationTypesUniqueness(
        MicroserviceMapping microserviceMapping) {
        checkCommunicationTypeUniqueness(microserviceMapping.protocols)
        checkEndpointProtocolUniqueness(microserviceMapping.endpoints)
    }

    /**
     * Check that communication types and endpoint protocols  of technology-specific protocol
     * specifications of an interface mapping are unique
     */
    @Check
    def checkProtocolSpecificationCommunicationTypesUniqueness(InterfaceMapping interfaceMapping) {
        checkCommunicationTypeUniqueness(interfaceMapping.protocols)
        checkEndpointProtocolUniqueness(interfaceMapping.endpoints)
    }

    /**
     * Check that communication types and endpoint protocols  of technology-specific protocol
     * specifications of an operation mapping are unique
     */
    @Check
    def checkProtocolSpecificationCommunicationTypesUniqueness(OperationMapping operationMapping) {
        checkCommunicationTypeUniqueness(operationMapping.protocols)
        checkEndpointProtocolUniqueness(operationMapping.endpoints)
    }

    /**
     * Check that communication types and endpoint protocols  of technology-specific protocol
     * specifications of a referred operation mapping are unique
     */
    @Check
    def checkProtocolSpecificationCommunicationTypesUniqueness(
        ReferredOperationMapping operationMapping) {
        checkCommunicationTypeUniqueness(operationMapping.protocols)
        checkEndpointProtocolUniqueness(operationMapping.endpoints)
    }

    /**
     * Helper to check that protocol/format combinations in endpoint mappings are unique
     */
    private def checkEndpointProtocolUniqueness(List<TechnologySpecificEndpoint> endpoints) {
        val protocolSet = <String> newHashSet
        endpoints.forEach[endpoint |
            for (i : 0..<endpoint.technologySpecificProtocols.size) {
                val technologySpecificProtocol = endpoint.technologySpecificProtocols.get(i)
                var protocolId = technologySpecificProtocol.protocol.name
                if (protocolId !== null && technologySpecificProtocol.dataFormat !== null)
                    protocolId += "/" + technologySpecificProtocol.dataFormat.formatName
                val boolean isDuplicate = if (protocolId !== null)
                    !protocolSet.add(protocolId)
                else
                    false

                if (isDuplicate)
                    error('''Duplicate protocol specification for endpoint «protocolId»''',
                        endpoint, MappingPackage::Literals
                            .TECHNOLOGY_SPECIFIC_ENDPOINT__TECHNOLOGY_SPECIFIC_PROTOCOLS, i)
            }
        ]
    }

    /**
     * Check uniqueness of an endpoint's addresses
     */
    @Check
    def checkUniqueEndpointAddresses(TechnologySpecificEndpoint endpoint) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(endpoint.addresses, [it])
        if (duplicateIndex > -1) {
            val duplicate = endpoint.addresses.get(duplicateIndex)
            error('''Duplicate address «duplicate»''', endpoint,
                MappingPackage::Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, duplicateIndex)
        }
    }

    /**
     * Warn about non-unique microservice endpoints' addresses per protocol/data format combination
     */
    @Check
    def warnkUniqueEndpointAddresses(TechnologyMapping model) {
        val allImportedServiceModels = model.imports
            .filter[importType === ImportType.MICROSERVICES]
            .map[
                    val serviceModelFile = DdmmUtils.getFileForResource(eResource)
                    val modelFileUri = DdmmUtils.convertToAbsoluteFileUri(
                        importURI,
                        serviceModelFile.rawLocation.makeAbsolute.toString
                    )
                    DdmmUtils.getImportedModelRoot(eResource, modelFileUri, ServiceModel)
                ]
        val allMappedMicroservices = model.serviceMappings.map[microservice.microservice].toList
        val nonMappedMicroservices = allImportedServiceModels
            .map[microservices]
            .flatten
            .filter[!allMappedMicroservices.contains(it)]

        val allMappedEndpoints = model.serviceMappings.map[endpoints].flatten.toList
        val nonMappedEndpoints = nonMappedMicroservices.map[endpoints].flatten.toList

        warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "microservice",
            [
                return if (it instanceof Endpoint)
                    it.microservice.buildQualifiedName(".")
                else if (it instanceof TechnologySpecificEndpoint)
                    it.microserviceMapping.microservice.microservice.buildQualifiedName(".")
                else
                    null
            ]
        )
    }

    /**
     * Warn about non-unique interface endpoints' addresses per protocol/data format combination
     */
    @Check
    def warnUniqueEndpointAddresses(MicroserviceMapping serviceMapping) {
        val mappedInterfaces = serviceMapping.interfaceMappings.map[interface]
        val nonMappedInterfaces = serviceMapping.microservice.microservice.interfaces
            .filter[!mappedInterfaces.contains(it)]

        val allMappedEndpoints = serviceMapping.interfaceMappings.map[endpoints].flatten.toList
        val nonMappedEndpoints = nonMappedInterfaces.map[endpoints].flatten.toList

        warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "interface",
            [
                return if (it instanceof Endpoint)
                    it.interface.buildQualifiedName(".")
                else if (it instanceof TechnologySpecificEndpoint)
                    it.interfaceMapping.interface.buildQualifiedName(".")
                else
                    null
            ]
        )
    }

    /**
     * Warn if operation and referred operation endpoints' addresses are not unique per
     * protocol/data format combination
     */
    @Check
    def warnUniqueEndpointAddressesOfOperations(MicroserviceMapping serviceMapping) {
        /* Collect all interfaces of mapped operations and referred operation */
        val mappedOperationsInterfaces = serviceMapping.operationMappings
            .map[operation.interface].toSet + serviceMapping.referredOperationMappings
            .map[operation.interface].toSet

        val mappedMicroservice = serviceMapping.microservice.microservice
        mappedOperationsInterfaces.forEach[currentInterface |
            /* Collect all mapped operations and referred operations of the current interface */
            val mappedOperationsOfInterface = (
                serviceMapping.operationMappings
                    .filter[operation.interface == currentInterface] +
                serviceMapping.referredOperationMappings
                    .filter[operation.interface == currentInterface]
            ).toList

            val nonMappedOperationsOfInterface = (
                mappedMicroservice.containedOperations
                    .filter[
                        interface == currentInterface &&
                        !mappedOperationsOfInterface.contains(it)
                    ] +
                mappedMicroservice.containedReferredOperations
                    .filter[
                        interface == currentInterface &&
                        !mappedOperationsOfInterface.contains(it)
                    ]
            ).toList

            /* Collect all mapped and non-mapped endpoints of operations in the current interface */
            val allMappedEndpoints = mappedOperationsOfInterface.map[
                if (it instanceof OperationMapping)
                    it.endpoints
                else if (it instanceof ReferredOperationMapping)
                    it.endpoints
            ].flatten.toList

            val nonMappedEndpoints = nonMappedOperationsOfInterface.map[
                if (it instanceof Operation)
                    it.endpoints
                else if (it instanceof ReferredOperation)
                    it.endpoints
            ].flatten.toList

            /* Warn about non-unique endpoints of operations in the current interface */
            warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "operation",
                [
                    return if (it instanceof Endpoint) {
                        if (it.operation !== null)
                            it.operation.buildQualifiedName(".")
                        else if (it.referredOperation !== null)
                            it.referredOperation.buildQualifiedName(".")
                    } else if (it instanceof TechnologySpecificEndpoint) {
                        if (it.operationMapping !== null)
                            it.operationMapping.operation.buildQualifiedName(".")
                        else if (it.referredOperationMapping !== null)
                            it.referredOperationMapping.operation.buildQualifiedName(".")
                    } else
                        null
                ]
            )
        ]
    }

    /**
     * Helper to warn if addresses of mapped as well as non-mapped endpoints are not unique in the
     * context of a given container, e.g., a microservice
     */
    private def warnUniqueEndpointAddresses(List<TechnologySpecificEndpoint> mappedEndpoints,
        List<Endpoint> nonMappedEndpoints, String containerTypeName,
        Function<EObject, String> getContainerName) {
        val mappedAddressesToEndpoints = <String, TechnologySpecificEndpoint>newHashMap

        /*
         * Check uniqueness of mapped endpoints' addresses, i.e., the addresses of endpoints
         * specified in the mapping model
         */
        mappedEndpoints.forEach[endpoint |
            for (i : 0..<endpoint.addresses.size) {
                endpoint.technologySpecificProtocols.forEach[protocol |
                    val address = endpoint.addresses.get(i)
                    var protocolName = protocol.technology.name + "::" + protocol.protocol.name
                    val dataFormat = protocol.dataFormat
                    if (dataFormat !== null && dataFormat.formatName !== null)
                        protocolName += "/" + dataFormat.formatName
                    val addressPrefixedByProtocol = protocolName + address

                    if (mappedAddressesToEndpoints.containsKey(addressPrefixedByProtocol)) {
                        val containerName = getContainerName.apply(endpoint)
                        error('''Address «address» is already specified for protocol ''' +
                            '''«protocolName» on «containerTypeName» «containerName»''', endpoint,
                            MappingPackage::Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, i)
                    } else
                        mappedAddressesToEndpoints.put(addressPrefixedByProtocol, endpoint)
                ]
            }
        ]

        /*
         * Check uniqueness of non-mapped endpoints' addresses, i.e., consider also the addresses of
         * endpoints directly specified in imported service models
         */
        nonMappedEndpoints.forEach[nonMappedEndpoint |
            for (i : 0..<nonMappedEndpoint.addresses.size) {
                nonMappedEndpoint.protocols.forEach[protocol |
                    val address = nonMappedEndpoint.addresses.get(i)
                    var protocolName = protocol.import.name + "::" + protocol.importedProtocol.name
                    val dataFormat = protocol.dataFormat
                    if (dataFormat !== null && dataFormat.formatName !== null)
                        protocolName += "/" + dataFormat.formatName
                    val addressPrefixedByProtocol = protocolName + address

                    val duplicateMappedEndpoint =
                        mappedAddressesToEndpoints.get(addressPrefixedByProtocol)
                    if (duplicateMappedEndpoint !== null) {
                        val mappedAddressIndex = duplicateMappedEndpoint.addresses.indexOf(address)
                        val mappedContainerName = getContainerName.apply(duplicateMappedEndpoint)
                        val containerName = getContainerName.apply(nonMappedEndpoint)

                        // A mapped endpoint address may overwrite the endpoint address of the
                        // original container
                        if (mappedContainerName != containerName) {
                            val serviceModelUri = DdmmUtils
                                .getFileForResource(nonMappedEndpoint.eResource)
                                .rawLocation.makeAbsolute.toString
                            warning('''Address «address» is already specified for protocol ''' +
                                '''«protocolName» on «containerTypeName» «containerName» in ''' +
                                '''service model «serviceModelUri»''', duplicateMappedEndpoint,
                                MappingPackage::Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES,
                                mappedAddressIndex)
                        }
                    }
                ]
            }
        ]
    }

    /**
     * Check and warn if types of a primitive parameter mapping are not compatible. Note that we
     * just place a warning in case of (suspected) type incompatibility, as we also do it in the
     * service DSL.
     */
    @Check
    def warnPrimitiveParameterMappingTypeCompatibility(PrimitiveParameterMapping mapping) {
        if (mapping.primitiveType !== null)
            warnPrimitiveTypeMappingCompatibility(mapping)
    }

    /**
     * Check and warn if types of a data field mapping are not compatible. Note that we just place a
     * warning in case of (suspected) type incompatibility, as we also do it in the service DSL.
     */
    @Check
    def warnComplexParameterMappingTypeCompatibility(TechnologySpecificFieldMapping mapping) {
        // We only consider primitive mappings for checking type compatibility, because if the
        // mapped type is a technology-specific complex type, type checking makes not sense at all
        // because technology-specific complex type don't exhibit any type-checking relevant
        // information, e.g., a structure consisting of typed fields
        if (mapping.isPrimitiveTypeMapping)
            warnPrimitiveTypeMappingCompatibility(mapping)
    }

    /**
     * Check for differing technology assignments to parameters
     */
    @Check
    def checkDifferingParameterTechnologies(MicroserviceMapping mapping) {
        if (mapping.technologyReferences.empty || mapping.microservice === null ||
            mapping.microservice.microservice === null) {
            return
        }

        val mappedService = mapping.microservice.microservice
        if (mappedService.technologyReferences.empty) {
            return
        }

        val mappedServiceTypeTechnologyImport = mappedService.typeDefinitionTechnologyImport
        if (mappedServiceTypeTechnologyImport === null) {
            return
        }
        val mappedServiceModelPath = DdmmUtils
            .getFileForResource(mappedServiceTypeTechnologyImport.serviceModel.eResource)
            .rawLocation.makeAbsolute.toString
        val mappedTypeTechnologyPath = DdmmUtils.convertToAbsoluteFileUri(
            mappedServiceTypeTechnologyImport.importURI, mappedServiceModelPath
        )

        val mappingTypeTechnologyImport = mapping.typeDefinitionTechnologyImport
        if (mappingTypeTechnologyImport === null) {
            return
        }
        val mappingServiceModelPath = DdmmUtils.getFileForResource(mapping.eResource)
            .rawLocation.makeAbsolute.toString
        val mappingTypeTechnologyPath = DdmmUtils.convertToAbsoluteFileUri(
            mappingTypeTechnologyImport.importURI, mappingServiceModelPath
        )

        if (mappedTypeTechnologyPath == mappingTypeTechnologyPath) {
            return
        }

        val mappedServiceOperations = mappedService.containedOperations
        mappedServiceOperations.addAll(mappedService.containedReferredOperations.map[operation])
        if (mappedServiceOperations.exists[parameters.exists[isTechnologySpecificEffectiveType]])
            error('''Type definition technology "«mappedService.typeDefinitionTechnology.name»"''' +
                ''' in the service model differs from type definition technology ''' +
                '''"«mapping.typeDefinitionTechnology.name»" used for the mapping. Moreover, ''' +
                '''the mapped microservice refers to technology-specific types in the ''' +
                '''parameters of its operations. Subsequent transformations of the ''' +
                '''microservice will not be possible. Please remove the technology-dependence ''' +
                '''of the service in its service model.''', mapping,
                MappingPackage::Literals.MICROSERVICE_MAPPING__MICROSERVICE)
    }

    /**
     * Check that interface mapping is not empty
     */
    @Check
    def checkNotEmpty(InterfaceMapping mapping) {
        val isEmpty = mapping.protocols.empty &&
            mapping.endpoints.empty &&
            mapping.aspects.empty

        if (isEmpty)
            error("Mapping must not be empty", mapping,
                MappingPackage::Literals.INTERFACE_MAPPING__INTERFACE)
    }

    /**
     * Check that operation mapping is not empty
     */
    @Check
    def checkNotEmpty(OperationMapping mapping) {
        val isEmpty = mapping.protocols.empty &&
            mapping.endpoints.empty &&
            mapping.parameterMappings.empty &&
            mapping.aspects.empty

        if (isEmpty)
            error("Mapping must not be empty", mapping,
                MappingPackage::Literals.OPERATION_MAPPING__OPERATION)
    }

    /**
     * Check that referred operation mapping is not empty
     */
    @Check
    def checkNotEmpty(ReferredOperationMapping mapping) {
        val isEmpty = mapping.protocols.empty &&
            mapping.endpoints.empty &&
            mapping.aspects.empty

        if (isEmpty)
            error("Mapping must not be empty", mapping,
                MappingPackage::Literals.REFERRED_OPERATION_MAPPING__OPERATION)
    }

    /**
     * Check that primitive parameter mapping is not empty
     */
    @Check
    def checkNotEmpty(PrimitiveParameterMapping mapping) {
        val isEmpty = mapping.primitiveType === null && mapping.aspects.empty

        if (isEmpty)
            error("Mapping must not be empty", mapping,
                MappingPackage::Literals.PARAMETER_MAPPING__PARAMETER)
    }

    /**
     * Check that complex parameter mapping is not empty
     */
    @Check
    def checkNotEmpty(ComplexParameterMapping mapping) {
        val isEmpty = mapping.technologySpecificComplexType === null &&
            mapping.aspects.empty &&
            mapping.fieldMappings.empty

        if (isEmpty)
            error("Mapping must not be empty", mapping,
                MappingPackage::Literals.PARAMETER_MAPPING__PARAMETER)
    }

    /**
     * Check that a parameter is mapped only once in an operation mapping
     */
    @Check
    def checkComplexParameterMappingUniqueParameters(OperationMapping mapping) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(mapping.parameterMappings, [parameter])
        if (duplicateIndex > -1) {
            val duplicateMapping = mapping.parameterMappings.get(duplicateIndex)
            val duplicateParameter = mapping.parameterMappings.get(duplicateIndex).parameter
            error('''Duplicate mapping for parameter «duplicateParameter.name»''',
                duplicateMapping, MappingPackage::Literals.PARAMETER_MAPPING__PARAMETER)
        }
    }

    /**
     * Check that a field is mapped only once in a complex parameter mapping
     */
    @Check
    def checkComplexParameterMappingUniqueFields(ComplexParameterMapping mapping) {
        checkFieldMappingUniqueness(mapping.parameter.importedType.type as ComplexType,
            mapping.fieldMappings)
    }

    /**
     * Check that a field is mapped only once in a complex type mapping
     */
    @Check
    def checkComplexTypeMappingUniqueFields(ComplexTypeMapping mapping) {
        checkFieldMappingUniqueness(mapping.type.type, mapping.fieldMappings)
    }

    /**
     * Helper to check that fields are mapped only once
     */
    private def checkFieldMappingUniqueness(ComplexType type,
        List<TechnologySpecificFieldMapping> mappings) {
        val duplicateIndex = if (type.isEnumeration)
                DdmmUtils.getDuplicateIndex(mappings, [enumerationField])
            else
                DdmmUtils.getDuplicateIndex(mappings, [dataField])

        if (duplicateIndex == -1) {
            return
        }

        val duplicateMapping = mappings.get(duplicateIndex)
        var String duplicateFieldName
        var EReference duplicateFieldReference
        if (type.isEnumeration) {
            duplicateFieldName = duplicateMapping.enumerationField.name
            duplicateFieldReference = MappingPackage::Literals
                .TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD
        } else {
            duplicateFieldName = duplicateMapping.dataField.name
            duplicateFieldReference = MappingPackage::Literals
                .TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD
        }

        error('''Duplicate mapping for field «duplicateFieldName»''', duplicateMapping,
            duplicateFieldReference)
    }

    /**
     * Check that a technology-specific field mapping is not empty
     */
    @Check
    def checkTechnologySpecificFieldMappingNotEmpty(TechnologySpecificFieldMapping mapping) {
        // Enumeration mappings can't be empty per grammar definition
        if (mapping.dataField === null) {
            return
        }

        if (mapping.type === null && mapping.aspects.empty)
            error("Data field mapping must not be empty", mapping,
                MappingPackage::Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD)
    }

    /**
     * Helper to check that communication types are unique
     */
    private def checkCommunicationTypeUniqueness(
        List<TechnologySpecificProtocolSpecification> protocolSpecifications) {
        for (int i : 0..<2) {
            val CommunicationType currentCommunicationType = switch (i) {
                case 0: CommunicationType.SYNCHRONOUS
                case 1: CommunicationType.ASYNCHRONOUS
            }

            val String currentCommunicationTypeName = switch (currentCommunicationType) {
                case SYNCHRONOUS: "synchronous"
                case ASYNCHRONOUS: "asynchronous"
            }

            val duplicateIndex = DdmmUtils.getDuplicateIndex(protocolSpecifications,
                [communicationType], [currentCommunicationType == it.communicationType])
            if (duplicateIndex === -1) {
                return
            }

            val duplicate = protocolSpecifications.get(duplicateIndex)
            error('''There must not be more than one «currentCommunicationTypeName» protocol ''' +
                '''being mapped''', duplicate, MappingPackage::Literals
                    .TECHNOLOGY_SPECIFIC_PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE)
        }
    }

    /**
     * Helper to check that service-specific mappings are unique
     */
    private def <T extends EObject> checkMappingUniqueness(List<T> mappingsToCheck,
        String mappingName, Function<T, String> getMappingObjectName, EReference mappingFeature) {
        return checkMappingUniqueness(mappingsToCheck, getMappingObjectName, mappingFeature,
            '''«mappingName» is already mapped''')
    }

    /**
     * Helper to check that service-specific mappings are unique with a custom error message
     */
    private def <T extends EObject> checkMappingUniqueness(List<T> mappingsToCheck,
        Function<T, String> getMappingObjectName, EReference mappingFeature, String errorMessage) {
        val duplicateIndex = DdmmUtils.getDuplicateIndex(mappingsToCheck, getMappingObjectName)

        if (duplicateIndex === -1) {
            return false
        }

        val duplicate = mappingsToCheck.get(duplicateIndex)
        error(errorMessage, duplicate, mappingFeature)
        return true
    }

    /**
     * Convenience method for warning if types of a parameter mapping are not compatible with each
     * other
     */
    def warnPrimitiveTypeMappingCompatibility(EObject mapping) {
        if (!mapping.isPrimitiveTypeMapping)
            return

        /*
         * Determine mapped type, its name, the original type, and the feature to place the warning
         * on
         */
        var Type mappedType
        var String mappedTypeName
        var Type originalType
        var EStructuralFeature erroneousMappingFeature
        switch (mapping) {
            // Primitive parameter mapping
            PrimitiveParameterMapping: {
                mappedType = mapping.primitiveType
                mappedTypeName = mapping.primitiveType.name
                originalType = mapping.parameter.primitiveType
                erroneousMappingFeature = MappingPackage::Literals.PARAMETER_MAPPING__PARAMETER
            }

            // Primitive data field mapping
            TechnologySpecificFieldMapping: {
                mappedType = mapping.type
                mappedTypeName = (mappedType as TechnologySpecificPrimitiveType).name
                originalType = mapping.dataField.effectiveType
                erroneousMappingFeature = MappingPackage::Literals
                    .TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD
            }
        }

        // Might happen if there are syntax errors in the model because a non-existing parameter or
        // type was specified
        if (originalType === null || mappedType === null) {
            return
        }

        /* Perform the actual type check */
        try {
            new TypeChecker().checkTypeCompatibility(originalType, mappedType)
        } catch (TypesNotCompatibleException ex) {
            val originalTypeName = buildMappedTypeQualifiedName(mapping, originalType)
            warning('''Original type «originalTypeName» of parameter is not directly ''' +
                '''compatible with mapped type «mappedTypeName» ''', mapping,
                erroneousMappingFeature)
        }
    }

    /**
     * Helper to check if a mapping is for a primitive type
     */
    private def isPrimitiveTypeMapping(EObject mapping) {
        return mapping instanceof PrimitiveParameterMapping ||
            if (mapping instanceof TechnologySpecificFieldMapping)
                mapping.type instanceof TechnologySpecificPrimitiveType
            else
                false
    }

    /**
     * Check uniqueness of aspects
     */
    @Check
    def checkAspectsUniqueness(TechnologySpecificImportedServiceAspect importedAspect) {
        if (importedAspect.technology === null || importedAspect.technology.name === null ||
            importedAspect.aspect === null || importedAspect.aspect.name === null) {
            return
        }

        val allAspectsOfContainer = EcoreUtil2.getSiblingsOfType(importedAspect.eContainer,
            TechnologySpecificImportedServiceAspect)
        val duplicateIndex = DdmmUtils.getDuplicateIndex(allAspectsOfContainer,
            [QualifiedName.create(importedAspect.technology.name, aspect.name).toString],
            [aspect.name !== null])
        if (duplicateIndex > -1) {
            val duplicateAspect = allAspectsOfContainer.get(duplicateIndex)
            error("Aspect was already specified", duplicateAspect, MappingPackage
                .Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)
        }
    }

    /**
     * Check that aspect has only one property, if only a single value is specified, and that the
     * specified value matches the property's type
     */
    @Check
    def checkSingleAspectProperty(TechnologySpecificImportedServiceAspect importedAspect) {
        val propertyValue = importedAspect.singlePropertyValue
        if (propertyValue === null) {
            return
        }

        val propertyCount = importedAspect.aspect.properties.size
        if (propertyCount === 0)
            error("Aspect does not define properties", importedAspect, MappingPackage
                .Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        else if (propertyCount > 1)
            error("Ambiguous value assignment", importedAspect, MappingPackage
                    .Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        else if (propertyCount === 1) {
            val targetProperty = importedAspect.aspect.properties.get(0)
            val targetPropertyType = targetProperty.type
            if (!propertyValue.isOfType(targetPropertyType))
                error('''Value is not of type «targetPropertyType.typeName» as expected by ''' +
                '''property «targetProperty.name»''', importedAspect, MappingPackage
                    .Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        }
    }

    /**
     * Check that mandatory properties of aspects have values
     */
    @Check
    def checkMandatoryAspectProperties(TechnologySpecificImportedServiceAspect importedAspect) {
        val aspect = importedAspect.aspect
        val aspectProperties = aspect.properties
        val mandatoryProperties = aspectProperties.filter[isMandatory]
        val mandatoryPropertiesWithoutValues = mandatoryProperties.filter[
            !importedAspect.values.map[property].contains(it)
        ]
        val allMandatoryPropertiesHaveValues = mandatoryPropertiesWithoutValues.empty

        val aspectHasExactlyOneMandatoryProperty = aspectProperties.size === 1 &&
            !mandatoryProperties.empty
        if (aspectHasExactlyOneMandatoryProperty) {
            if (importedAspect.singlePropertyValue === null && !allMandatoryPropertiesHaveValues) {
                val mandatoryProperty = mandatoryProperties.get(0)
                error('''Mandatory property «mandatoryProperty.name» does not have value''',
                    importedAspect, MappingPackage
                        .Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)
            }
        } else if (!allMandatoryPropertiesHaveValues) {
            mandatoryPropertiesWithoutValues.forEach[
               error('''Mandatory property «name» does not have value''', importedAspect,
                    MappingPackage.Literals::TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)
            ]
        }
    }

    /**
     * Convenience method to build a qualified name for a type being used in a parameter mapping
     */
    private def buildMappedTypeQualifiedName(EObject mapping, Type type) {
        var String importAlias
        var List<String> nameParts

        /* Get alias (if type is imported) and name parts of fully-qualified type name */
        switch (mapping) {
            /* Primitive parameter mapping */
            PrimitiveParameterMapping:
                switch (type) {
                    // Primitive type is imported from a technology model
                    TechnologySpecificPrimitiveType: {
                        importAlias = mapping.parameter.importedType.import.name
                        nameParts = type.qualifiedNameParts
                    }

                    // Built-in primitive type
                    PrimitiveType: nameParts = #[type.typeName]
                }

            /* Complex parameter mapping */
            ComplexParameterMapping:
                switch (type) {
                    ComplexType: {
                        importAlias = mapping.parameter.importedType.import.name
                        nameParts = type.qualifiedNameParts
                    }
                }

            /*
             * Data field mapping. A data field either has a built-in primitive type or a complex
             * type from a data model. It may not have a technology-specific type of any kind
             * assigned.
             */
            TechnologySpecificFieldMapping:
                switch (type) {
                    // Built-in primitive type
                    PrimitiveType: nameParts = #[type.typeName]

                    // Complex type being imported from data model
                    ComplexType: {
                        importAlias = mapping.parameterMapping.parameter.importedType.import.name
                        nameParts = type.qualifiedNameParts
                    }
            }
        }

        var qualifiedName = QualifiedName.create(nameParts).toString
        if (importAlias !== null)
            qualifiedName = importAlias + "::" + qualifiedName
        return qualifiedName
    }
}
