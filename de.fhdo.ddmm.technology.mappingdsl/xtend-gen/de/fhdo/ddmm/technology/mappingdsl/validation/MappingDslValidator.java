/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.mappingdsl.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.ddmm.data.ComplexType;
import de.fhdo.ddmm.data.DataField;
import de.fhdo.ddmm.data.EnumerationField;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.PrimitiveValue;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.Microservice;
import de.fhdo.ddmm.service.Operation;
import de.fhdo.ddmm.service.Parameter;
import de.fhdo.ddmm.service.ReferredOperation;
import de.fhdo.ddmm.service.ServicePackage;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificProperty;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.technology.mapping.ComplexParameterMapping;
import de.fhdo.ddmm.technology.mapping.ComplexTypeMapping;
import de.fhdo.ddmm.technology.mapping.ImportedComplexType;
import de.fhdo.ddmm.technology.mapping.ImportedMicroservice;
import de.fhdo.ddmm.technology.mapping.InterfaceMapping;
import de.fhdo.ddmm.technology.mapping.MappingPackage;
import de.fhdo.ddmm.technology.mapping.MicroserviceMapping;
import de.fhdo.ddmm.technology.mapping.OperationMapping;
import de.fhdo.ddmm.technology.mapping.ParameterMapping;
import de.fhdo.ddmm.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.ddmm.technology.mapping.ReferredOperationMapping;
import de.fhdo.ddmm.technology.mapping.TechnologyMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificFieldMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.ddmm.technology.mappingdsl.validation.AbstractMappingDslValidator;
import de.fhdo.ddmm.typechecking.TypeChecker;
import de.fhdo.ddmm.typechecking.TypesNotCompatibleException;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains validation rules for the Mapping DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class MappingDslValidator extends AbstractMappingDslValidator {
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final TechnologyMapping model) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = DdmmUtils.<Import, String>getDuplicateIndex(model.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = model.getImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      ServicePackage.Literals.IMPORT__IMPORT_URI);
  }
  
  /**
   * Check that technology is assigned only once to a complex type mapping
   */
  @Check
  public void checkTechnologyUniqueness(final ComplexTypeMapping mapping) {
    final Function<Import, Import> _function = (Import it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<Import, Import>getDuplicateIndex(mapping.getTechnologies(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate technology assignment", 
        MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGIES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that technology is assigned only once to a microservice mapping
   */
  @Check
  public void checkTechnologyUniqueness(final MicroserviceMapping mapping) {
    final Function<Import, Import> _function = (Import it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<Import, Import>getDuplicateIndex(mapping.getTechnologies(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate technology assignment", 
        MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that only one annotated technology of a complex type mapping contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnology(final ComplexTypeMapping mapping) {
    this.checkUniqueTypeDefinitionTechnology(mapping, mapping.getTechnologies(), 
      MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGIES);
  }
  
  /**
   * Check that only one annotated technology of a microservice mapping contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnology(final MicroserviceMapping mapping) {
    this.checkUniqueTypeDefinitionTechnology(mapping, mapping.getTechnologies(), 
      MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES);
  }
  
  /**
   * Helper to check that only one annotated technology contains type definitions
   */
  private void checkUniqueTypeDefinitionTechnology(final EObject mapping, final List<Import> technologies, final EReference feature) {
    String typeDefinitionTechnologyName = null;
    int _size = technologies.size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = technologies.get((i).intValue());
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if ((((!technologyModel.getPrimitiveTypes().isEmpty()) || 
          (!technologyModel.getListTypes().isEmpty())) || 
          (!technologyModel.getDataStructures().isEmpty()))) {
          if ((typeDefinitionTechnologyName == null)) {
            typeDefinitionTechnologyName = technologyModel.getName();
          } else {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Technology \"");
            _builder.append(typeDefinitionTechnologyName);
            _builder.append("\" already defines ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("technology-specific types");
            String _plus = (_builder.toString() + _builder_1);
            this.error(_plus, mapping, feature, (i).intValue());
          }
        }
      }
    }
  }
  
  /**
   * Check that annotated technologies of complex type mappings define not only deployment-related
   * concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final ComplexTypeMapping mapping) {
    this.checkTechnologiesForServiceConcepts(mapping, mapping.getTechnologies(), 
      MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGIES);
  }
  
  /**
   * Check that annotated technologies of microservice mappings define not only deployment-related
   * concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final MicroserviceMapping mapping) {
    this.checkTechnologiesForServiceConcepts(mapping, mapping.getTechnologies(), 
      MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES);
  }
  
  /**
   * Helper to check that annotated technologies define not only deployment-related concepts
   */
  public void checkTechnologiesForServiceConcepts(final EObject mapping, final List<Import> technologies, final EReference feature) {
    int _size = technologies.size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = technologies.get((i).intValue());
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if (((technologyModel.getPrimitiveTypes().isEmpty() && 
          technologyModel.getProtocols().isEmpty()) && 
          technologyModel.getServiceAspects().isEmpty())) {
          this.error("Technology does not specify service-related concepts", mapping, feature, (i).intValue());
        }
      }
    }
  }
  
  /**
   * Check technologies of a microservice mapping per communication type for unambiguous default
   * protocols
   */
  @Check
  public void checkTechnologiesForUniqueDefaultProtocols(final MicroserviceMapping mapping) {
    boolean _isEmpty = mapping.getTechnologies().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Function1<CommunicationType, Boolean> _function = (CommunicationType communicationType) -> {
      final Function1<TechnologySpecificProtocolSpecification, Boolean> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Boolean.valueOf((communicationType == _communicationType));
      };
      boolean _exists = IterableExtensions.<TechnologySpecificProtocolSpecification>exists(mapping.getProtocols(), _function_1);
      return Boolean.valueOf((!_exists));
    };
    final Function1<CommunicationType, Boolean> _function_1 = (CommunicationType it) -> {
      boolean _isDefaultProtocolUnique = this.isDefaultProtocolUnique(mapping, it);
      return Boolean.valueOf((!_isDefaultProtocolUnique));
    };
    final Iterable<CommunicationType> nonUniqueCommunicationTypes = IterableExtensions.<CommunicationType>filter(IterableExtensions.<CommunicationType>filter(((Iterable<CommunicationType>)Conversions.doWrapArray(CommunicationType.values())), _function), _function_1);
    for (final CommunicationType communicationType : nonUniqueCommunicationTypes) {
      {
        String _switchResult = null;
        if (communicationType != null) {
          switch (communicationType) {
            case ASYNCHRONOUS:
              _switchResult = "asynchronous";
              break;
            case SYNCHRONOUS:
              _switchResult = "synchronous";
              break;
            default:
              break;
          }
        }
        final String typeString = _switchResult;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Ambiguous default protocol for ");
        _builder.append(typeString);
        _builder.append(" communication. The ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("mapping needs to explicitly specifiy a protocol for ");
        _builder_1.append(typeString);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("communication.");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, mapping, 
          MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
      }
    }
  }
  
  /**
   * Helper to check if default protocol of a microservice mapping is unique for a given
   * communication type
   */
  private boolean isDefaultProtocolUnique(final MicroserviceMapping mapping, final CommunicationType communicationType) {
    boolean alreadyFoundDefaultProtocolForCommunicationType = false;
    EList<Import> _technologies = mapping.getTechnologies();
    for (final Import technologyImport : _technologies) {
      {
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final boolean hasDefaultProtocolForCommunicationType = IterableExtensions.<Protocol>exists(technologyModel.getProtocols(), _function);
        if (hasDefaultProtocolForCommunicationType) {
          if (alreadyFoundDefaultProtocolForCommunicationType) {
            return false;
          } else {
            alreadyFoundDefaultProtocolForCommunicationType = true;
          }
        }
      }
    }
    return true;
  }
  
  /**
   * Check that service mappings are unique
   */
  @Check
  public boolean checkMicroserviceMappingUniqueness(final TechnologyMapping model) {
    boolean _xblockexpression = false;
    {
      final Function1<MicroserviceMapping, Boolean> _function = (MicroserviceMapping it) -> {
        boolean _isEmpty = it.getTechnologies().isEmpty();
        return Boolean.valueOf((!_isEmpty));
      };
      final List<MicroserviceMapping> modelMappingsWithTechnology = IterableExtensions.<MicroserviceMapping>toList(IterableExtensions.<MicroserviceMapping>filter(model.getServiceMappings(), _function));
      final Function<MicroserviceMapping, String> _function_1 = (MicroserviceMapping it) -> {
        ImportedMicroservice _microservice = it.getMicroservice();
        Import _import = null;
        if (_microservice!=null) {
          _import=_microservice.getImport();
        }
        String _name = null;
        if (_import!=null) {
          _name=_import.getName();
        }
        return _name;
      };
      final Function<MicroserviceMapping, List<String>> _function_2 = (MicroserviceMapping it) -> {
        return it.getMicroservice().getMicroservice().getQualifiedNameParts();
      };
      _xblockexpression = this.<MicroserviceMapping>checkFirstLevelMappingUniqueness(modelMappingsWithTechnology, 
        "Service", _function_1, _function_2, 
        MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
    return _xblockexpression;
  }
  
  /**
   * Check that complex type mappings are unique
   */
  @Check
  public boolean checkComplexTypeMappingUniqueness(final TechnologyMapping model) {
    boolean _xblockexpression = false;
    {
      final Function1<ComplexTypeMapping, Boolean> _function = (ComplexTypeMapping it) -> {
        boolean _isEmpty = it.getTechnologies().isEmpty();
        return Boolean.valueOf((!_isEmpty));
      };
      final List<ComplexTypeMapping> modelMappingsWithTechnology = IterableExtensions.<ComplexTypeMapping>toList(IterableExtensions.<ComplexTypeMapping>filter(model.getTypeMappings(), _function));
      final Function<ComplexTypeMapping, String> _function_1 = (ComplexTypeMapping it) -> {
        ImportedComplexType _type = it.getType();
        Import _dataModelImport = null;
        if (_type!=null) {
          _dataModelImport=_type.getDataModelImport();
        }
        String _name = null;
        if (_dataModelImport!=null) {
          _name=_dataModelImport.getName();
        }
        return _name;
      };
      final Function<ComplexTypeMapping, List<String>> _function_2 = (ComplexTypeMapping it) -> {
        return it.getType().getType().getQualifiedNameParts();
      };
      _xblockexpression = this.<ComplexTypeMapping>checkFirstLevelMappingUniqueness(modelMappingsWithTechnology, 
        "Type", _function_1, _function_2, 
        MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TYPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Helper to check that mappings of elements on the first level of the mapping model like
   * complex types and microservices are unique. This check considers duplicate mappings of
   * elements defined in the same source model, as well as duplicate mappings of elements from
   * different source models.
   */
  private <T extends EObject> boolean checkFirstLevelMappingUniqueness(final List<T> mappings, final String mappingName, final Function<T, String> getImportName, final Function<T, List<String>> getQualifiedNameParts, final EReference mappedElementFeature) {
    boolean _xblockexpression = false;
    {
      final Function<T, String> _function = (T it) -> {
        String _xblockexpression_1 = null;
        {
          final ArrayList<String> qualifiedNameSegments = CollectionLiterals.<String>newArrayList();
          final String importName = getImportName.apply(it);
          if ((importName != null)) {
            qualifiedNameSegments.add(importName);
          }
          qualifiedNameSegments.addAll(getQualifiedNameParts.apply(it));
          _xblockexpression_1 = QualifiedName.create(qualifiedNameSegments).toString();
        }
        return _xblockexpression_1;
      };
      final boolean duplicateMappingFound = this.<T>checkMappingUniqueness(mappings, mappingName, _function, mappedElementFeature);
      boolean _xifexpression = false;
      if ((!duplicateMappingFound)) {
        final Function<T, String> _function_1 = (T it) -> {
          return QualifiedName.create(getQualifiedNameParts.apply(it)).toString();
        };
        StringConcatenation _builder = new StringConcatenation();
        _builder.append(mappingName);
        _builder.append(" with the same qualified name but from another model has ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("already been mapped");
        String _plus = (_builder.toString() + _builder_1);
        _xifexpression = this.<T>checkMappingUniqueness(mappings, _function_1, mappedElementFeature, _plus);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Check that interface mappings are unique
   */
  @Check
  public boolean checkInterfaceMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<InterfaceMapping, String> _function = (InterfaceMapping it) -> {
      return QualifiedName.create(it.getInterface().getQualifiedNameParts()).toString();
    };
    return this.<InterfaceMapping>checkMappingUniqueness(microserviceMapping.getInterfaceMappings(), "Interface", _function, 
      MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
  }
  
  /**
   * Check that operation mappings are unique
   */
  @Check
  public boolean checkOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<OperationMapping, String> _function = (OperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    return this.<OperationMapping>checkMappingUniqueness(microserviceMapping.getOperationMappings(), "Operation", _function, 
      MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that referred operation mappings are unique
   */
  @Check
  public boolean checkReferredOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<ReferredOperationMapping, String> _function = (ReferredOperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    return this.<ReferredOperationMapping>checkMappingUniqueness(microserviceMapping.getReferredOperationMappings(), "Referred operation", _function, 
      MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that communication types and endpoint protocols of technology-specific protocol
   * specifications of a microservice mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final MicroserviceMapping microserviceMapping) {
    this.checkCommunicationTypeUniqueness(microserviceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(microserviceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an interface mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final InterfaceMapping interfaceMapping) {
    this.checkCommunicationTypeUniqueness(interfaceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(interfaceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final OperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of a referred operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final ReferredOperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Helper to check that protocol/format combinations in endpoint mappings are unique
   */
  private void checkEndpointProtocolUniqueness(final List<TechnologySpecificEndpoint> endpoints) {
    final HashSet<String> protocolSet = CollectionLiterals.<String>newHashSet();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getTechnologySpecificProtocols().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          final TechnologySpecificProtocol technologySpecificProtocol = endpoint.getTechnologySpecificProtocols().get((i).intValue());
          String protocolId = technologySpecificProtocol.getProtocol().getName();
          if (((protocolId != null) && (technologySpecificProtocol.getDataFormat() != null))) {
            String _protocolId = protocolId;
            String _formatName = technologySpecificProtocol.getDataFormat().getFormatName();
            String _plus = ("/" + _formatName);
            protocolId = (_protocolId + _plus);
          }
          boolean _xifexpression = false;
          if ((protocolId != null)) {
            boolean _add = protocolSet.add(protocolId);
            _xifexpression = (!_add);
          } else {
            _xifexpression = false;
          }
          final boolean isDuplicate = _xifexpression;
          if (isDuplicate) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Duplicate protocol specification for endpoint ");
            _builder.append(protocolId);
            this.error(_builder.toString(), endpoint, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__TECHNOLOGY_SPECIFIC_PROTOCOLS, (i).intValue());
          }
        }
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Check uniqueness of an endpoint's addresses
   */
  @Check
  public void checkUniqueEndpointAddresses(final TechnologySpecificEndpoint endpoint) {
    final Function<String, String> _function = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<String, String>getDuplicateIndex(endpoint.getAddresses(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final String duplicate = endpoint.getAddresses().get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate address ");
      _builder.append(duplicate);
      this.error(_builder.toString(), endpoint, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that mapped microservice, interface, and operation technology-specific endpoints'
   * addresses are unique per protocol/data format combination
   */
  @Check
  public void checkUniqueEndpointAddresses(final TechnologyMapping model) {
    final Function1<MicroserviceMapping, EList<TechnologySpecificEndpoint>> _function = (MicroserviceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> microserviceEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<MicroserviceMapping, EList<TechnologySpecificEndpoint>>map(model.getServiceMappings(), _function)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_1 = (TechnologySpecificEndpoint it) -> {
      EList<String> _xblockexpression = null;
      {
        final ImportedMicroservice importedMicroservice = it.getMicroserviceMapping().getMicroservice();
        _xblockexpression = importedMicroservice.getMicroservice().getQualifiedNameParts();
      }
      return _xblockexpression;
    };
    this.checkUniqueEndpointAddresses(microserviceEndpoints, "microservice", _function_1);
    final Function1<InterfaceMapping, EList<TechnologySpecificEndpoint>> _function_2 = (InterfaceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> interfaceEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<InterfaceMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedInterfaces(), _function_2)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_3 = (TechnologySpecificEndpoint it) -> {
      return it.getInterfaceMapping().getInterface().getQualifiedNameParts();
    };
    this.checkUniqueEndpointAddresses(interfaceEndpoints, "interface", _function_3);
    final List<TechnologySpecificEndpoint> operationEndpoints = CollectionLiterals.<TechnologySpecificEndpoint>newArrayList();
    final Function1<ReferredOperationMapping, EList<TechnologySpecificEndpoint>> _function_4 = (ReferredOperationMapping it) -> {
      return it.getEndpoints();
    };
    Iterables.<TechnologySpecificEndpoint>addAll(operationEndpoints, Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<ReferredOperationMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedReferredOperations(), _function_4)));
    final Function1<OperationMapping, EList<TechnologySpecificEndpoint>> _function_5 = (OperationMapping it) -> {
      return it.getEndpoints();
    };
    Iterables.<TechnologySpecificEndpoint>addAll(operationEndpoints, Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<OperationMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedOperations(), _function_5)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_6 = (TechnologySpecificEndpoint it) -> {
      EList<String> _xifexpression = null;
      OperationMapping _operationMapping = it.getOperationMapping();
      boolean _tripleNotEquals = (_operationMapping != null);
      if (_tripleNotEquals) {
        _xifexpression = it.getOperationMapping().getOperation().getQualifiedNameParts();
      } else {
        EList<String> _xifexpression_1 = null;
        ReferredOperationMapping _referredOperationMapping = it.getReferredOperationMapping();
        boolean _tripleNotEquals_1 = (_referredOperationMapping != null);
        if (_tripleNotEquals_1) {
          _xifexpression_1 = it.getReferredOperationMapping().getOperation().getQualifiedNameParts();
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.checkUniqueEndpointAddresses(operationEndpoints, "operation", _function_6);
  }
  
  /**
   * Check and warn if types of a primitive parameter mapping are not compatible. Note that we
   * just place a warning in case of (suspected) type incompatibility, as we also do it in the
   * service DSL.
   */
  @Check
  public void warnPrimitiveParameterMappingTypeCompatibility(final PrimitiveParameterMapping mapping) {
    TechnologySpecificPrimitiveType _primitiveType = mapping.getPrimitiveType();
    boolean _tripleNotEquals = (_primitiveType != null);
    if (_tripleNotEquals) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Check and warn if types of a data field mapping are not compatible. Note that we just place a
   * warning in case of (suspected) type incompatibility, as we also do it in the service DSL.
   */
  @Check
  public void warnComplexParameterMappingTypeCompatibility(final TechnologySpecificFieldMapping mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    if (_isPrimitiveTypeMapping) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Check for differing technology assignments to parameters
   */
  @Check
  public void checkDifferingParameterTechnologies(final MicroserviceMapping mapping) {
    if (((mapping.getTechnologies().isEmpty() || (mapping.getMicroservice() == null)) || 
      (mapping.getMicroservice().getMicroservice() == null))) {
      return;
    }
    final Microservice mappedService = mapping.getMicroservice().getMicroservice();
    boolean _isEmpty = mappedService.getTechnologies().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Import mappedServiceTypeTechnologyImport = mappedService.getTypeDefinitionTechnologyImport();
    if ((mappedServiceTypeTechnologyImport == null)) {
      return;
    }
    final String mappedServiceModelPath = DdmmUtils.getFileForResource(mappedServiceTypeTechnologyImport.getServiceModel().eResource()).getRawLocation().makeAbsolute().toString();
    final String mappedTypeTechnologyPath = DdmmUtils.convertToAbsoluteFileUri(
      mappedServiceTypeTechnologyImport.getImportURI(), mappedServiceModelPath);
    final Import mappingTypeTechnologyImport = mapping.getTypeDefinitionTechnologyImport();
    if ((mappingTypeTechnologyImport == null)) {
      return;
    }
    final String mappingServiceModelPath = DdmmUtils.getFileForResource(mapping.eResource()).getRawLocation().makeAbsolute().toString();
    final String mappingTypeTechnologyPath = DdmmUtils.convertToAbsoluteFileUri(
      mappingTypeTechnologyImport.getImportURI(), mappingServiceModelPath);
    boolean _equals = Objects.equal(mappedTypeTechnologyPath, mappingTypeTechnologyPath);
    if (_equals) {
      return;
    }
    final EList<Operation> mappedServiceOperations = mappedService.getContainedOperations();
    final Function1<ReferredOperation, Operation> _function = (ReferredOperation it) -> {
      return it.getOperation();
    };
    mappedServiceOperations.addAll(ListExtensions.<ReferredOperation, Operation>map(mappedService.getContainedReferredOperations(), _function));
    final Function1<Operation, Boolean> _function_1 = (Operation it) -> {
      final Function1<Parameter, Boolean> _function_2 = (Parameter it_1) -> {
        return Boolean.valueOf(it_1.isTechnologySpecificEffectiveType());
      };
      return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getParameters(), _function_2));
    };
    boolean _exists = IterableExtensions.<Operation>exists(mappedServiceOperations, _function_1);
    if (_exists) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Type definition technology \"");
      String _name = mappedService.getTypeDefinitionTechnology().getName();
      _builder.append(_name);
      _builder.append("\"");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(" ");
      _builder_1.append("in the service model differs from type definition technology ");
      String _plus = (_builder.toString() + _builder_1);
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("\"");
      String _name_1 = mapping.getTypeDefinitionTechnology().getName();
      _builder_2.append(_name_1);
      _builder_2.append("\" used for the mapping. Moreover, ");
      String _plus_1 = (_plus + _builder_2);
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append("the mapped microservice refers to technology-specific types in the ");
      String _plus_2 = (_plus_1 + _builder_3);
      StringConcatenation _builder_4 = new StringConcatenation();
      _builder_4.append("parameters of its operations. Subsequent transformations of the ");
      String _plus_3 = (_plus_2 + _builder_4);
      StringConcatenation _builder_5 = new StringConcatenation();
      _builder_5.append("microservice will not be possible. Please remove the technology-dependence ");
      String _plus_4 = (_plus_3 + _builder_5);
      StringConcatenation _builder_6 = new StringConcatenation();
      _builder_6.append("of the service in its service model.");
      String _plus_5 = (_plus_4 + _builder_6);
      this.error(_plus_5, mapping, 
        MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
  }
  
  /**
   * Check that interface mapping is not empty
   */
  @Check
  public void checkNotEmpty(final InterfaceMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
    }
  }
  
  /**
   * Check that operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final OperationMapping mapping) {
    final boolean isEmpty = (((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getParameterMappings().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that referred operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final ReferredOperationMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that primitive parameter mapping is not empty
   */
  @Check
  public void checkNotEmpty(final PrimitiveParameterMapping mapping) {
    final boolean isEmpty = ((mapping.getPrimitiveType() == null) && mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that complex parameter mapping is not empty
   */
  @Check
  public void checkNotEmpty(final ComplexParameterMapping mapping) {
    final boolean isEmpty = (((mapping.getTechnologySpecificComplexType() == null) && 
      mapping.getAspects().isEmpty()) && 
      mapping.getFieldMappings().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that a parameter is mapped only once in an operation mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueParameters(final OperationMapping mapping) {
    final Function<ParameterMapping, Parameter> _function = (ParameterMapping it) -> {
      return it.getParameter();
    };
    final Integer duplicateIndex = DdmmUtils.<ParameterMapping, Parameter>getDuplicateIndex(mapping.getParameterMappings(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final ParameterMapping duplicateMapping = mapping.getParameterMappings().get((duplicateIndex).intValue());
      final Parameter duplicateParameter = mapping.getParameterMappings().get((duplicateIndex).intValue()).getParameter();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate mapping for parameter ");
      String _name = duplicateParameter.getName();
      _builder.append(_name);
      this.error(_builder.toString(), duplicateMapping, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that a field is mapped only once in a complex parameter mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueFields(final ComplexParameterMapping mapping) {
    Type _type = mapping.getParameter().getImportedType().getType();
    this.checkFieldMappingUniqueness(((ComplexType) _type), 
      mapping.getFieldMappings());
  }
  
  /**
   * Check that a field is mapped only once in a complex type mapping
   */
  @Check
  public void checkComplexTypeMappingUniqueFields(final ComplexTypeMapping mapping) {
    this.checkFieldMappingUniqueness(mapping.getType().getType(), mapping.getFieldMappings());
  }
  
  /**
   * Helper to check that fields are mapped only once
   */
  private void checkFieldMappingUniqueness(final ComplexType type, final List<TechnologySpecificFieldMapping> mappings) {
    Integer _xifexpression = null;
    boolean _isIsEnumeration = type.isIsEnumeration();
    if (_isIsEnumeration) {
      final Function<TechnologySpecificFieldMapping, EnumerationField> _function = (TechnologySpecificFieldMapping it) -> {
        return it.getEnumerationField();
      };
      _xifexpression = DdmmUtils.<TechnologySpecificFieldMapping, EnumerationField>getDuplicateIndex(mappings, _function);
    } else {
      final Function<TechnologySpecificFieldMapping, DataField> _function_1 = (TechnologySpecificFieldMapping it) -> {
        return it.getDataField();
      };
      _xifexpression = DdmmUtils.<TechnologySpecificFieldMapping, DataField>getDuplicateIndex(mappings, _function_1);
    }
    final Integer duplicateIndex = _xifexpression;
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final TechnologySpecificFieldMapping duplicateMapping = mappings.get((duplicateIndex).intValue());
    String duplicateFieldName = null;
    EReference duplicateFieldReference = null;
    boolean _isIsEnumeration_1 = type.isIsEnumeration();
    if (_isIsEnumeration_1) {
      duplicateFieldName = duplicateMapping.getEnumerationField().getName();
      duplicateFieldReference = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD;
    } else {
      duplicateFieldName = duplicateMapping.getDataField().getName();
      duplicateFieldReference = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD;
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate mapping for field ");
    _builder.append(duplicateFieldName);
    this.error(_builder.toString(), duplicateMapping, duplicateFieldReference);
  }
  
  /**
   * Check that a technology-specific field mapping is not empty
   */
  @Check
  public void checkTechnologySpecificFieldMappingNotEmpty(final TechnologySpecificFieldMapping mapping) {
    DataField _dataField = mapping.getDataField();
    boolean _tripleEquals = (_dataField == null);
    if (_tripleEquals) {
      return;
    }
    if (((mapping.getType() == null) && mapping.getAspects().isEmpty())) {
      this.error("Data field mapping must not be empty", mapping, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD);
    }
  }
  
  /**
   * Helper to check that communication types are unique
   */
  private void checkCommunicationTypeUniqueness(final List<TechnologySpecificProtocolSpecification> protocolSpecifications) {
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final int i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        switch (i) {
          case 0:
            _switchResult = CommunicationType.SYNCHRONOUS;
            break;
          case 1:
            _switchResult = CommunicationType.ASYNCHRONOUS;
            break;
        }
        final CommunicationType currentCommunicationType = _switchResult;
        String _switchResult_1 = null;
        if (currentCommunicationType != null) {
          switch (currentCommunicationType) {
            case SYNCHRONOUS:
              _switchResult_1 = "synchronous";
              break;
            case ASYNCHRONOUS:
              _switchResult_1 = "asynchronous";
              break;
            default:
              break;
          }
        }
        final String currentCommunicationTypeName = _switchResult_1;
        final Function<TechnologySpecificProtocolSpecification, CommunicationType> _function = (TechnologySpecificProtocolSpecification it) -> {
          return it.getCommunicationType();
        };
        final Predicate<TechnologySpecificProtocolSpecification> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Objects.equal(currentCommunicationType, _communicationType);
        };
        final Integer duplicateIndex = DdmmUtils.<TechnologySpecificProtocolSpecification, CommunicationType>getDuplicateIndex(protocolSpecifications, _function, _function_1);
        if (((duplicateIndex).intValue() == (-1))) {
          return;
        }
        final TechnologySpecificProtocolSpecification duplicate = protocolSpecifications.get((duplicateIndex).intValue());
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("There must not be more than one ");
        _builder.append(currentCommunicationTypeName);
        _builder.append(" protocol ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("being mapped");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, duplicate, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE);
      }
    }
  }
  
  /**
   * Helper to check that service-specific mappings are unique
   */
  private <T extends EObject> boolean checkMappingUniqueness(final List<T> mappingsToCheck, final String mappingName, final Function<T, String> getMappingObjectName, final EReference mappingFeature) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(mappingName);
    _builder.append(" is already mapped");
    return this.<T>checkMappingUniqueness(mappingsToCheck, getMappingObjectName, mappingFeature, _builder.toString());
  }
  
  /**
   * Helper to check that service-specific mappings are unique with a custom error message
   */
  private <T extends EObject> boolean checkMappingUniqueness(final List<T> mappingsToCheck, final Function<T, String> getMappingObjectName, final EReference mappingFeature, final String errorMessage) {
    final Integer duplicateIndex = DdmmUtils.<T, String>getDuplicateIndex(mappingsToCheck, getMappingObjectName);
    if (((duplicateIndex).intValue() == (-1))) {
      return false;
    }
    final T duplicate = mappingsToCheck.get((duplicateIndex).intValue());
    this.error(errorMessage, duplicate, mappingFeature);
    return true;
  }
  
  /**
   * Convenience method to check uniqueness of endpoint addresses within a list of endpoints
   */
  private void checkUniqueEndpointAddresses(final List<TechnologySpecificEndpoint> endpoints, final String containerTypeName, final Function<TechnologySpecificEndpoint, List<String>> getEndpointContainerNameParts) {
    final HashMap<String, Map<String, Object>> uniqueAddressMap = CollectionLiterals.<String, Map<String, Object>>newHashMap();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<TechnologySpecificProtocol> _function_1 = (TechnologySpecificProtocol technologySpecificProtocol) -> {
          final String address = endpoint.getAddresses().get((i).intValue());
          final Protocol protocol = technologySpecificProtocol.getProtocol();
          String protocolName = protocol.getName();
          final DataFormat dataFormat = technologySpecificProtocol.getDataFormat();
          if (((dataFormat != null) && (dataFormat.getFormatName() != null))) {
            String _protocolName = protocolName;
            String _formatName = dataFormat.getFormatName();
            String _plus = ("/" + _formatName);
            protocolName = (_protocolName + _plus);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          final HashMap<String, Object> valueMap = CollectionLiterals.<String, Object>newHashMap();
          valueMap.put("protocol", protocolName);
          valueMap.put("endpoint", endpoint);
          final Map<String, Object> duplicate = uniqueAddressMap.putIfAbsent(addressPrefixedByProtocol, valueMap);
          TechnologySpecificEndpoint _xifexpression = null;
          if ((duplicate != null)) {
            Object _get = duplicate.get("endpoint");
            _xifexpression = ((TechnologySpecificEndpoint) _get);
          }
          final TechnologySpecificEndpoint duplicateEndpoint = _xifexpression;
          if (((duplicateEndpoint != null) && (duplicateEndpoint != endpoint))) {
            Object _get_1 = duplicate.get("protocol");
            final String duplicateProtocolName = ((String) _get_1);
            final List<String> duplicateContainerNameParts = getEndpointContainerNameParts.apply(duplicateEndpoint);
            final List<String> currentEndpointContainerNameParts = getEndpointContainerNameParts.apply(endpoint);
            final String relativeDuplicateName = QualifiedName.create(
              DdmmUtils.<TechnologySpecificEndpoint, TechnologyMapping>calculateRelativeQualifiedNameParts(duplicateEndpoint, duplicateContainerNameParts, TechnologyMapping.class, endpoint, currentEndpointContainerNameParts, TechnologyMapping.class)).toString();
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Address is already specified for protocol ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append(duplicateProtocolName);
            _builder_1.append(" on ");
            String _plus_1 = (_builder.toString() + _builder_1);
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append(containerTypeName);
            _builder_2.append(" ");
            _builder_2.append(relativeDuplicateName);
            String _plus_2 = (_plus_1 + _builder_2);
            this.error(_plus_2, endpoint, 
              MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (i).intValue());
          }
        };
        endpoint.getTechnologySpecificProtocols().forEach(_function_1);
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Convenience method for warning if types of a parameter mapping are not compatible with each
   * other
   */
  public void warnPrimitiveTypeMappingCompatibility(final EObject mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    boolean _not = (!_isPrimitiveTypeMapping);
    if (_not) {
      return;
    }
    Type mappedType = null;
    String mappedTypeName = null;
    Type originalType = null;
    EStructuralFeature erroneousMappingFeature = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      mappedType = ((PrimitiveParameterMapping)mapping).getPrimitiveType();
      mappedTypeName = ((PrimitiveParameterMapping)mapping).getPrimitiveType().getName();
      originalType = ((PrimitiveParameterMapping)mapping).getParameter().getPrimitiveType();
      erroneousMappingFeature = MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER;
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        mappedType = ((TechnologySpecificFieldMapping)mapping).getType();
        mappedTypeName = ((TechnologySpecificPrimitiveType) mappedType).getName();
        originalType = ((TechnologySpecificFieldMapping)mapping).getDataField().getEffectiveType();
        erroneousMappingFeature = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD;
      }
    }
    if (((originalType == null) || (mappedType == null))) {
      return;
    }
    try {
      new TypeChecker().checkTypeCompatibility(originalType, mappedType);
    } catch (final Throwable _t) {
      if (_t instanceof TypesNotCompatibleException) {
        final String originalTypeName = this.buildMappedTypeQualifiedName(mapping, originalType);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Original type ");
        _builder.append(originalTypeName);
        _builder.append(" of parameter is not directly ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("compatible with mapped type ");
        _builder_1.append(mappedTypeName);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        this.warning(_plus, mapping, erroneousMappingFeature);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  /**
   * Helper to check if a mapping is for a primitive type
   */
  private boolean isPrimitiveTypeMapping(final EObject mapping) {
    boolean _or = false;
    if ((mapping instanceof PrimitiveParameterMapping)) {
      _or = true;
    } else {
      boolean _xifexpression = false;
      if ((mapping instanceof TechnologySpecificFieldMapping)) {
        Type _type = ((TechnologySpecificFieldMapping)mapping).getType();
        _xifexpression = (_type instanceof TechnologySpecificPrimitiveType);
      } else {
        _xifexpression = false;
      }
      _or = _xifexpression;
    }
    return _or;
  }
  
  /**
   * Check uniqueness of aspects
   */
  @Check
  public void checkAspectsUniqueness(final TechnologySpecificImportedServiceAspect importedAspect) {
    if (((((importedAspect.getTechnology() == null) || (importedAspect.getTechnology().getName() == null)) || 
      (importedAspect.getAspect() == null)) || (importedAspect.getAspect().getName() == null))) {
      return;
    }
    final List<TechnologySpecificImportedServiceAspect> allAspectsOfContainer = EcoreUtil2.<TechnologySpecificImportedServiceAspect>getSiblingsOfType(importedAspect.eContainer(), 
      TechnologySpecificImportedServiceAspect.class);
    final Function<TechnologySpecificImportedServiceAspect, String> _function = (TechnologySpecificImportedServiceAspect it) -> {
      return QualifiedName.create(importedAspect.getTechnology().getName(), it.getAspect().getName()).toString();
    };
    final Predicate<TechnologySpecificImportedServiceAspect> _function_1 = (TechnologySpecificImportedServiceAspect it) -> {
      String _name = it.getAspect().getName();
      return (_name != null);
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologySpecificImportedServiceAspect, String>getDuplicateIndex(allAspectsOfContainer, _function, _function_1);
    if (((duplicateIndex).intValue() > (-1))) {
      final TechnologySpecificImportedServiceAspect duplicateAspect = allAspectsOfContainer.get((duplicateIndex).intValue());
      this.error("Aspect was already specified", duplicateAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
    }
  }
  
  /**
   * Check that aspect has only one property, if only a single value is specified, and that the
   * specified value matches the property's type
   */
  @Check
  public void checkSingleAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    final PrimitiveValue propertyValue = importedAspect.getSinglePropertyValue();
    if ((propertyValue == null)) {
      return;
    }
    final int propertyCount = importedAspect.getAspect().getProperties().size();
    if ((propertyCount == 0)) {
      this.error("Aspect does not define properties", importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
    } else {
      if ((propertyCount > 1)) {
        this.error("Ambiguous value assignment", importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
      } else {
        if ((propertyCount == 1)) {
          final TechnologySpecificProperty targetProperty = importedAspect.getAspect().getProperties().get(0);
          final PrimitiveType targetPropertyType = targetProperty.getType();
          boolean _isOfType = propertyValue.isOfType(targetPropertyType);
          boolean _not = (!_isOfType);
          if (_not) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Value is not of type ");
            String _typeName = targetPropertyType.getTypeName();
            _builder.append(_typeName);
            _builder.append(" as expected by ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("property ");
            String _name = targetProperty.getName();
            _builder_1.append(_name);
            String _plus = (_builder.toString() + _builder_1);
            this.error(_plus, importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
          }
        }
      }
    }
  }
  
  /**
   * Check that mandatory properties of aspects have values
   */
  @Check
  public void checkMandatoryAspectProperties(final TechnologySpecificImportedServiceAspect importedAspect) {
    final ServiceAspect aspect = importedAspect.getAspect();
    final EList<TechnologySpecificProperty> aspectProperties = aspect.getProperties();
    final Function1<TechnologySpecificProperty, Boolean> _function = (TechnologySpecificProperty it) -> {
      return Boolean.valueOf(it.isMandatory());
    };
    final Iterable<TechnologySpecificProperty> mandatoryProperties = IterableExtensions.<TechnologySpecificProperty>filter(aspectProperties, _function);
    final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
      final Function1<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty> _function_2 = (TechnologySpecificPropertyValueAssignment it_1) -> {
        return it_1.getProperty();
      };
      boolean _contains = ListExtensions.<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty>map(importedAspect.getValues(), _function_2).contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<TechnologySpecificProperty> mandatoryPropertiesWithoutValues = IterableExtensions.<TechnologySpecificProperty>filter(mandatoryProperties, _function_1);
    final boolean allMandatoryPropertiesHaveValues = IterableExtensions.isEmpty(mandatoryPropertiesWithoutValues);
    final boolean aspectHasExactlyOneMandatoryProperty = ((aspectProperties.size() == 1) && 
      (!IterableExtensions.isEmpty(mandatoryProperties)));
    if (aspectHasExactlyOneMandatoryProperty) {
      if (((importedAspect.getSinglePropertyValue() == null) && (!allMandatoryPropertiesHaveValues))) {
        final TechnologySpecificProperty mandatoryProperty = ((TechnologySpecificProperty[])Conversions.unwrapArray(mandatoryProperties, TechnologySpecificProperty.class))[0];
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Mandatory property ");
        String _name = mandatoryProperty.getName();
        _builder.append(_name);
        _builder.append(" does not have value");
        this.error(_builder.toString(), importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
      }
    } else {
      if ((!allMandatoryPropertiesHaveValues)) {
        final Consumer<TechnologySpecificProperty> _function_2 = (TechnologySpecificProperty it) -> {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Mandatory property ");
          String _name_1 = it.getName();
          _builder_1.append(_name_1);
          _builder_1.append(" does not have value");
          this.error(_builder_1.toString(), importedAspect, 
            MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
        };
        mandatoryPropertiesWithoutValues.forEach(_function_2);
      }
    }
  }
  
  /**
   * Convenience method to build a qualified name for a type being used in a parameter mapping
   */
  private String buildMappedTypeQualifiedName(final EObject mapping, final Type type) {
    String importAlias = null;
    List<String> nameParts = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      boolean _matched_1 = false;
      if (type instanceof TechnologySpecificPrimitiveType) {
        _matched_1=true;
        importAlias = ((PrimitiveParameterMapping)mapping).getParameter().getImportedType().getImport().getName();
        nameParts = ((TechnologySpecificPrimitiveType)type).getQualifiedNameParts();
      }
      if (!_matched_1) {
        if (type instanceof PrimitiveType) {
          _matched_1=true;
          String _typeName = ((PrimitiveType)type).getTypeName();
          nameParts = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_typeName));
        }
      }
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        boolean _matched_1 = false;
        if (type instanceof ComplexType) {
          _matched_1=true;
          importAlias = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getImport().getName();
          nameParts = ((ComplexType)type).getQualifiedNameParts();
        }
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        boolean _matched_1 = false;
        if (type instanceof PrimitiveType) {
          _matched_1=true;
          String _typeName = ((PrimitiveType)type).getTypeName();
          nameParts = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_typeName));
        }
        if (!_matched_1) {
          if (type instanceof ComplexType) {
            _matched_1=true;
            importAlias = ((TechnologySpecificFieldMapping)mapping).getParameterMapping().getParameter().getImportedType().getImport().getName();
            nameParts = ((ComplexType)type).getQualifiedNameParts();
          }
        }
      }
    }
    String qualifiedName = QualifiedName.create(nameParts).toString();
    if ((importAlias != null)) {
      qualifiedName = ((importAlias + "::") + qualifiedName);
    }
    return qualifiedName;
  }
}
